<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Shadow Facets of Concurrency</title>

		<meta name="description" content="Reveal.js version of Shadow Facets of Concurrency prsentation">
		<meta name="author" content="Eugene Kalenkovich">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/serif.css" id="theme">
    <link rel="stylesheet" href="css/concur.css">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="css/github.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="reveal/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
        <!-- Rails: Shadow Facets of Concurrency --><section>
          <h2>Rails: Shadow Facets of Concurrency</h2>

          <small>
            <p align="right">
              Eugene Kalenkovich
            </p>
            <p align="right">
              <a href="http://twitter.com/UncleGene">@UncleGene</a>
            </p>
          </small>
          <br />
          <br />
          <br />
          <br />
          <pre align="right" class="w65"><code class="ruby" data-trim data-noescape>
audience.<em>except</em>(&:can_see_this).each do |person|
  # Please!
  person.move(:closer)
end
          </code></pre>
        </section>
        <!-- #1  You may not worry about concurrency if: --><section>
          <h2>
            You may not worry about concurrency if:
          </h2>
          <ul>
            <li class="fragment">You use Rails</li>
            <li class="fragment">Your application is single-threaded</li>
            <li class="fragment">You have a very low traffic</li>
          </ul>
          <h3 class="fragment">Do you worry?</h3>

        </section>
        <!-- #2    img: monorail --><section>
          <img src="images/SeattleMonorailAccident.jpg">
          <!-- cc 
            #CC-BY-SA-2.5 Garrett Fitzgerald
            #http://commons.wikimedia.org/wiki/File:SeattleMonorailAccident.jpg
          -->

        </section>
        <!-- #3  When? --><section>

          <h2>When?</h2>

        </section>
        <!-- #4    RAILS_ENV=development --><section>

          <h3>RAILS_ENV=development</h3>
          <img class="small" src="images/box_one_rails_one_db.png">

        </section>
        <!-- #5    RAILS_ENV=production --><section>

          <h3>RAILS_ENV=production</h3>
          <div>
            <img class="small" src="images/box_many_rails.png">
            <img class="small" src="images/box_one_db.png">
          </div>
          <div class="fragment subst" data-fragment-index="2">
            <img class="small" src="images/box_many_rails.png">
            <img class="small" src="images/box_many_rails.png">
            <img class="small" src="images/box_one_db.png">
            <img class="small" src="images/box_many_rails.png">
            <img class="small" src="images/box_many_rails.png">
          </div>

          <ul>
            <li class="fragment" data-fragment-index="1">Shared resources
            <li class="fragment" data-fragment-index="3">Non-deterministic request processing
            <ul>
              <li class="fragment" data-fragment-index="4">Who
              <li class="fragment" data-fragment-index="5">When
            </ul>
          </ul>

          </section>
        <!-- #6 Part 1. Rails and Concurrency --><section>

          <h2>Part 1</h2>
          <h3>Rails and Concurrency</h3>

        </section>
        <!-- #7    RAILS_ENV=test --><section>

          <h3>RAILS_ENV=test</h3>
          <div class="fragment">
            database.yml:
            <pre class="w55"><code data-trim>
test:
  adapter: postgresql  # mysql2
  database: your_db_test
            </code></pre>
          </div>
          <div class="fragment">
            test_helper.rb (spec_helper.rb):
            <pre class="w80"><code class="ruby" data-trim>
def concurrently processes = 10
  processes.times do
    fork do
      yield
    end
  end
  assert Process.waitall.map(&:last).all? &:success?
end
            </code></pre>
            <pre class="fragment w80 subst"><code class="ruby" data-noescape data-trim>
def concurrently processes = 10
  processes.times do
    <em>fork do</em>
      <em>yield</em>
    <em>end</em>
  end
  assert Process.waitall.map(&:last).all? &:success?
end
            </code></pre>
            <pre class="fragment w80 subst"><code class="ruby" data-noescape data-trim>
def concurrently processes = 10
  processes.times do
    fork do
      yield
    end
  end
  <em>assert Process.waitall.map(&:last).all? &:success?</em>
end
            </code></pre>
          </div>
        </section>
        <!-- #8    RAILS_ENV=test --><section>

          <h3>RAILS_ENV=test</h3>
          <pre class="w80"><code class="ruby" data-trim>
def concurrently processes = 10
  ActiveRecord::Base.remove_connection
  processes.times do
    fork do
      begin
        ActiveRecord::Base.establish_connection
        yield
      rescue => e
        puts "#{e.class.name}: #{e}" && exit 1
      ensure
        ActiveRecord::Base.remove_connection
      end
    end
  end
  ActiveRecord::Base.establish_connection
  assert Process.waitall.map(&:last).all? &:success?
end  
          </code></pre>

          <pre class="fragment w80 subst"><code class="ruby" data-noescape data-trim>
def concurrently processes = 10
  <em>ActiveRecord::Base.remove_connection</em>
  processes.times do
    fork do
      begin
        <em>ActiveRecord::Base.establish_connection</em>
        yield
      rescue => e
        puts "#{e.class.name}: #{e}" && exit 1
      ensure
        <em>ActiveRecord::Base.remove_connection</em>
      end
    end
  end
  <em>ActiveRecord::Base.establish_connection</em>
  assert Process.waitall.map(&:last).all? &:success?
end
          </code></pre>

          <pre class="fragment w80 subst"><code class="ruby" data-noescape data-trim>
def concurrently processes = 10
  ActiveRecord::Base.remove_connection
  processes.times do
    fork do
      begin
        ActiveRecord::Base.establish_connection
        yield
      <em>rescue => e</em>
        <em>puts "#{e.class.name}: #{e}" && exit 1</em>
      ensure
        ActiveRecord::Base.remove_connection
      end
    end
  end
  ActiveRecord::Base.establish_connection
  assert Process.waitall.map(&:last).all? &:success?
end
          </code></pre>

        </section>
        <!-- #9  Facet #1: One and Only --><section>

          <h2>Facet #1: One and Only</h2>
          <img src="images/unique_by_sorah42-d33i1bm.jpg">
          <!-- cc 
            cc by-sa 3.0 SoRah42
            http://sorah42.deviantart.com/art/Unique-187278898
          -->


        </section>
        <!-- #10    first_or_create --><section>

          <h3>first_or_create</h3>
          <pre class="fragment"><code class="ruby" data-trim>
class Number < ActiveRecord::Base
  # t.integer :value
end   
          </code></pre>

          <pre class="fragment"><code class="ruby" data-noescape data-trim>
describe Number do
  it 'should have unique values' do
    concurrently do
      10.times do
        Number.where(value: Number.count).first_or_create
      end
    end
    Number.count.must_equal Number.select('distinct value').count
  end
end
          </code></pre>
          <pre class="fragment subst"><code class="ruby" data-noescape data-trim>
describe Number do
  it 'should have unique values' do
    concurrently do
      10.times do
        <em>Number.where(value: Number.count).first_or_create</em>
      end
    end
    Number.count.must_equal Number.select('distinct value').count
  end
end
          </code></pre>
          <pre class="fragment subst"><code class="ruby" data-noescape data-trim>
describe Number do
  it 'should have unique values' do
    concurrently do
      10.times do
        Number.where(value: Number.count).first_or_create
      end
    end
    <em>Number.count.must_equal Number.select('distinct value').count</em>
  end
end
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
1) Failure:
test_0001_should_have_unique_values(Number) :
Expected: 49
  Actual: 99
          </code></pre>

        </section>
        <!-- #11      img: train over wall --><section>

          <img src="images/santa_fe.jpg">
          <!-- cc
            CC BY-NC-SA 2.0 John McNab
            http://www.flickr.com/photos/johnmcnab/6511819727/
          -->

        </section>
        <!-- #12    first_or_create.inspect --><section>

          <h3>first_or_create.inspect</h3>
          <div>
            <pre class="fragment" data-fragment-index="1"><code class="sql" data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
   (0.2ms)  BEGIN
  SQL (9.0ms)  INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]
   (0.4ms)  COMMIT
            </code></pre>
            <pre class="fragment subst" data-fragment-index="2"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  <em>SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1</em>
   (0.2ms)  BEGIN
  SQL (9.0ms)  INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]
   (0.4ms)  COMMIT
            </code></pre>
            <pre class="fragment subst" data-fragment-index="3"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
   (0.2ms)  BEGIN
  SQL (9.0ms)  <em>INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]</em>
   (0.4ms)  COMMIT
            </code></pre>

            <pre class="fragment" data-fragment-index="4"><code class="sql" data-trim>
> Number.where(value: 3).first_or_create
  Number Load (0.4ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
            </code></pre>
            <pre class="fragment subst" data-fragment-index="5"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (0.4ms)  <em>SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1</em>
            </code></pre>
          </div>

          <div class="fragment subst" data-fragment-index="6">
            <pre><code class="sql" data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
   (0.2ms)  BEGIN
  SQL (9.0ms)  INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]
   (0.4ms)  COMMIT
            </code></pre>
            <pre class="fragment subst" data-fragment-index="7"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  <em>SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1</em>
   (0.2ms)  BEGIN
  SQL (9.0ms)  INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]
   (0.4ms)  COMMIT
            </code></pre>
            <pre class="fragment subst" data-fragment-index="9"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
   (0.2ms)  BEGIN
  SQL (9.0ms)  <em>INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]</em>
   (0.4ms)  COMMIT
            </code></pre>

            <pre><code class="sql" data-trim>
> Number.where(value: 3).first_or_create
  Number Load (0.4ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
            </code></pre>
            <pre class="fragment subst" data-fragment-index="8"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (0.4ms)  <em>SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1</em>
            </code></pre>
            <pre class="fragment subst" data-fragment-index="10"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (0.4ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
   (0.2ms)  BEGIN
  SQL (0.3ms)  <em>INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]</em>
   (0.5ms)  COMMIT
            </code></pre>
          </div>


        </section>
        <!-- $13    validates :uniquiness --><section>

            <h3>validates :uniquiness</h3>

            <pre class="fragment"><code class="ruby" data-trim>
class ValidatedNumber < ActiveRecord::Base
  validates :value, uniqueness: true
end
            </code></pre>

            <pre class="fragment"><code class="ruby" data-trim>
describe ValidatedNumber do
  it 'should have unique values' do
    concurrently do
      10.times do
        ValidatedNumber.create{|r| r.value = ValidatedNumber.count}
      end
    end
    unique = ValidatedNumber.select("distinct value").count
    ValidatedNumber.count.must_equal unique
  end
end
            </code></pre>

<pre class="fragment"><code class="no-highlight">
1) Failure:
test_0001_should_have_unique_values(ValidatedNumber):
Expected: 37
  Actual: 96

            </code></pre>

            <pre class="fragment subst"><code class="sql" data-trim>
> ValidatedNumber.create(value: 1)
   (0.1ms)  BEGIN
  ValidatedNumber Exists (25.2ms)  SELECT 1 AS one FROM "validated_numbers" WHERE "validated_numbers"."value" = 1 LIMIT 1
  SQL (14.7ms)  INSERT INTO "validated_numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 1]]
   (0.7ms)  COMMIT
            </code></pre>
            <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> ValidatedNumber.create(value: 1)
   (0.1ms)  BEGIN
  ValidatedNumber Exists (25.2ms)  <em>SELECT 1 AS one FROM "validated_numbers" WHERE "validated_numbers"."value" = 1 LIMIT 1</em>
  SQL (14.7ms)  INSERT INTO "validated_numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 1]]
   (0.7ms)  COMMIT
          </code></pre>

        </section>
        <!-- #14      img: train wreck --><section>

            <img src="images/Train_wreck_at_Montparnasse_1895.jpg">
            <!-- cc
                PD
                http://en.wikipedia.org/wiki/File:Train_wreck_at_Montparnasse_1895.jpg
            -->

        </section>
        <!-- #15    unique.fix :db  --><section>

          <h3>unique.fix :db </h3>

          <pre class="fragment"><code class="ruby" data-trim>
class CreateConstrainedNumbers < ActiveRecord::Migration
  def change
    create_table :constrained_numbers do |t|
      t.integer :value
    end
    add_index :constrained_numbers, :value, unique: true
  end
end
          </code></pre>

          <pre class="fragment subst"><code class="ruby" data-trim data-noescape>
class CreateConstrainedNumbers < ActiveRecord::Migration
  def change
    create_table :constrained_numbers do |t|
      t.integer :value
    end
    <em>add_index :constrained_numbers, :value, unique: true</em>
  end
end
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
# Running tests:

ActiveRecord::RecordNotUnique: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
ActiveRecord::RecordNotUnique: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
ActiveRecord::RecordNotUnique: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
ActiveRecord::RecordNotUnique: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
ActiveRecord::RecordNotUnique: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
[...]
          </code></pre>

          <pre class="fragment subst"><code class="no-highlight" data-noescape data-trim>
# Running tests:

<em>ActiveRecord::RecordNotUnique</em>: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
<em>ActiveRecord::RecordNotUnique</em>: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
<em>ActiveRecord::RecordNotUnique</em>: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
<em>ActiveRecord::RecordNotUnique</em>: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
<em>ActiveRecord::RecordNotUnique</em>: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
[...]
          </code></pre>

        </section>
        <!-- #16      img: quake bent rails --><section>

          <img src="images/GuateQuake1976BentRailsA.jpg">
          <!-- cc
            Public Domain
            http://commons.wikimedia.org/wiki/File:GuateQuake1976BentRailsA.jpg
          -->

        </section>
        <!-- #17    unique.fix :db, diy: true --><section>

          <h3>unique.fix :db, diy: true</h3>

          <pre class="fragment"><code class="ruby" data-trim>
class SafeNumber < ActiveRecord::Base
  def self.first_or_create_where(*args)
    where(*args).first_or_create
  rescue ActiveRecord::RecordNotUnique
    retry
  end
end
          </code></pre>
          <pre class="fragment subst"><code class="ruby" data-noescape data-trim>
class SafeNumber < ActiveRecord::Base
  def self.first_or_create_where(*args)
    where(*args).first_or_create
  <em>rescue ActiveRecord::RecordNotUnique</em>
    <em>retry</em>
  end
end
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
# Running tests:

.

Finished tests in 8.337332s, 0.1199 tests/s, 0.2399 assertions/s.

1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
          </code></pre>

          <pre class="fragment"><code class="sql" data-trim>
ActiveRecord::StatementInvalid: Mysql2::Error: Deadlock found when trying to get lock; try restarting transaction: INSERT INTO `safe_numbers` (`value`) VALUES (132)
ActiveRecord::StatementInvalid: Mysql2::Error: Deadlock found when trying to get lock; try restarting transaction: INSERT INTO `safe_numbers` (`value`) VALUES (132)
F
          </code></pre>
          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
<em>ActiveRecord::StatementInvalid</em>: Mysql2::Error: <em>Deadlock found</em> when trying to get lock; try restarting transaction: INSERT INTO `safe_numbers` (`value`) VALUES (132)
<em>ActiveRecord::StatementInvalid</em>: Mysql2::Error: <em>Deadlock found</em> when trying to get lock; try restarting transaction: INSERT INTO `safe_numbers` (`value`) VALUES (132)
F
          </code></pre>

        </section>
        <!-- #18      img: curved rails --><section>

          <img src="images/4963981594_849491e7cc_o.jpg">
          <!-- cc
            CC BY-ND 2.0 Mike Campbell
            http://www.flickr.com/photos/morphyoss/4963981594/
          -->

        </section>
        <!-- #19    unique.fix :db, diy: true, mysql: true --><section>

          <h3>unique.fix :db, diy: true, mysql: true</h3>

          <pre class="fragment"><code class="ruby" data-trim>
def self.first_or_create_where(*args)
  where(*args).first_or_create
rescue ActiveRecord::RecordNotUnique
  retry
rescue ActiveRecord::StatementInvalid => e
  retry if e.message =~ /Deadlock/
  # Thank you, MySQL and Mysql2!
  raise
end
          </code></pre>
          <pre class="fragment subst"><code class="ruby" data-trim data-noescape>
def self.first_or_create_where(*args)
  where(*args).first_or_create
rescue ActiveRecord::RecordNotUnique
  retry
<em>rescue ActiveRecord::StatementInvalid => e</em>
  <em>retry if e.message =~ /Deadlock/</em>
  <em># Thank you, MySQL and Mysql2!</em>
  <em>raise</em>
end
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
# Running tests:

.

Finished tests in 3.234423s, 0.3092 tests/s, 0.6183 assertions/s.

1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
          </code></pre>

        </section>
        <!-- #20      img: fast train --><section>

          <img src="images/fast_train.jpg">
          <!-- cc
            CC-BY-NC-ND 3.0 Swansea
            http://www.freefoto.com/download/23-22-1/Swansea-London-Paddington-High-Speed-Train- -->

        </section>
        <!-- #21  Facet #2: I Can Haz One or Many? --><section>

          <ul>
            <li><h4>Facet #1: One and Only</h4></li>
            <li>
              <h2>Facet #2:<br/>I Can Haz One or Many?</h2>
              <h3>or Guilty by Association</h3>
            </li>
          </ul>

        </section>
        <!-- #22    class Dog --><section>

          <h3>class Dog</h3>

          <pre class="fragment w55"><code class="ruby" data-trim>
class Dog < ActiveRecord::Base
  has_one :head
  has_many :legs
end
          </code></pre>

          <pre class="fragment w55"><code class="ruby" data-trim>
class Head < ActiveRecord::Base
  belongs_to :dog
end

class Leg < ActiveRecord::Base
  belongs_to :dog
end
          </code></pre>

        </section>
        <!-- #23    Dog.build --><section>

          <h3>Dog.build</h3>

          <pre><code class="ruby" data-trim>
20.times{ Dog.create }

concurrently do
  begin
    headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
    headless && headless.create_head

    legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
    legless && legless.legs = 4.times.map{ Leg.create }
  end while headless || legless
end
          </code></pre>

          <pre class="fragment subst"><code class="ruby" data-trim data-noescape>
<em>20.times{ Dog.create }</em>

concurrently do
  begin
    headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
    headless && headless.create_head

    legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
    legless && legless.legs = 4.times.map{ Leg.create }
  end while headless || legless
end
          </code></pre>

          <pre class="fragment subst"><code class="ruby" data-trim data-noescape>
20.times{ Dog.create }

concurrently do
  begin
    <em>headless = Dog.includes(:head).where(heads: {dog_id: nil}).first</em>
    <em>headless && headless.create_head</em>

    legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
    legless && legless.legs = 4.times.map{ Leg.create }
  end while headless || legless
end
          </code></pre>

          <pre class="fragment subst"><code class="ruby" data-trim data-noescape>
20.times{ Dog.create }

concurrently do
  begin
    headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
    headless && headless.create_head

    <em>legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first</em>
    <em>legless && legless.legs = 4.times.map{ Leg.create }</em>
  end while headless || legless
end
          </code></pre>

        </section>
        <!-- #24    assert_sanity --><section>

          <h3>assert_sanity</h3>

          <pre><code class="ruby" data-trim>
pretty_report(Dog.all).must_equal "20 dogs with 1 head and 4 legs"
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
--- expected
+++ actual
@@ -1 +1 @@
-"20 dogs with 1 head and 4 legs"
+"3 dogs with 1 head and 8 legs, 2 dogs with 2 heads and 28 legs, 2 dogs with 1 head and 12 legs, 1 dog with 1 head and 4 legs, 1 dog with 4 heads and 24 legs, 1 dog with 4 heads and 32 legs, 1 dog with 3 heads and 16 legs, 1 dog with 2 heads and 32 legs, 1 dog with 1 head and 16 legs, 1 dog with 6 heads and 8 legs, 1 dog with 1 head and 20 legs, 1 dog with 2 heads and 16 legs, 1 dog with 4 heads and 36 legs, 1 dog with 5 heads and 24 legs, 1 dog with 8 heads and 20 legs, 1 dog with 2 heads and 40 legs"
          </code></pre>
          <pre class="fragment subst"><code class="no-highlight" data-trim data-noescape>
--- expected
+++ actual
@@ -1 +1 @@
-"20 dogs with 1 head and 4 legs"
+"3 dogs with 1 head and 8 legs, 2 dogs with 2 heads and 28 legs, 2 dogs with 1 head and 12 legs, <em>1 dog with 1 head and 4 legs</em>, 1 dog with 4 heads and 24 legs, 1 dog with 4 heads and 32 legs, 1 dog with 3 heads and 16 legs, 1 dog with 2 heads and 32 legs, 1 dog with 1 head and 16 legs, 1 dog with 6 heads and 8 legs, 1 dog with 1 head and 20 legs, 1 dog with 2 heads and 16 legs, 1 dog with 4 heads and 36 legs, 1 dog with 5 heads and 24 legs, 1 dog with 8 heads and 20 legs, 1 dog with 2 heads and 40 legs"
          </code></pre>

        </section>
        <!-- #25      img: crash --><section>

          <img src="images/crash.jpg">
          <!-- cc
            PD
            http://commons.wikimedia.org/wiki/File:Loket_vid_j%C3%A4rnv%C3%A4gsolyckan_i_Get%C3%A5_1918.jpg
          -->

        </section>
        <!-- #26    dog.head.inspect --><section>

          <h3>dog.head.inspect</h3>

          <pre class="fragment"><code class="sql" data-trim>
> Dog.first.create_head
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (12.0ms)  INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", 1]]
   (0.9ms)  COMMIT
  Head Load (0.2ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1 LIMIT 1
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 1
   (0.4ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> Dog.first.create_head
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (12.0ms)  <em>INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", 1]]</em>
   (0.9ms)  COMMIT
  Head Load (0.2ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1 LIMIT 1
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 1
   (0.4ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> Dog.first.create_head
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (12.0ms)  INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", 1]]
   (0.9ms)  COMMIT
  Head Load (0.2ms)  <em>SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1 LIMIT 1</em>
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 1
   (0.4ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> Dog.first.create_head
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (12.0ms)  INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", 1]]
   (0.9ms)  COMMIT
  Head Load (0.2ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1 <em>LIMIT 1</em>
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 1
   (0.4ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> Dog.first.create_head
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (12.0ms)  INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", 1]]
   (0.9ms)  COMMIT
  Head Load (0.2ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1<em> </em>LIMIT 1
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 1
   (0.4ms)  COMMIT
          </code></pre>

        </section>
        <!-- #27      img: many heads --><section>
          <img src="images/three_heads.jpg">

        </section>
        <!-- #28    dog.legs.inspect --><section>

          <h3>dog.legs.inspect</h3>

          <pre class="fragment"><code class="sql" data-trim>
>   Dog.first.legs = Leg.all.sample(4)
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
  Leg Load (0.2ms)  SELECT "legs".* FROM "legs"
  Leg Load (0.3ms)  SELECT "legs".* FROM "legs" WHERE "legs"."dog_id" = 1
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 6
   (0.2ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 3
   (0.2ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 10
   (0.1ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 5
   (0.5ms)  COMMIT
          </code></pre>

          <pre class="fragment"><code class="sql" data-noescape data-trim>
> Dog.first.legs = Leg.all.sample(4)
  Dog Load (0.4ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
  Leg Load (0.3ms)  SELECT "legs".* FROM "legs"
  Leg Load (0.3ms)  SELECT "legs".* FROM "legs" WHERE "legs"."dog_id" = 1
   (0.1ms)  BEGIN
  SQL (0.3ms)  <em>UPDATE "legs" SET "dog_id" = NULL WHERE "legs"."dog_id" = 1 AND "legs"."id" IN (10, 5)</em>
   (0.2ms)  <em>UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 2</em>
   (0.2ms)  <em>UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 9</em>
   (0.6ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> Dog.first.legs = Leg.all.sample(4)
  Dog Load (0.4ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
  Leg Load (0.3ms)  SELECT "legs".* FROM "legs"
  Leg Load (0.3ms)  <em>SELECT "legs".* FROM "legs" WHERE "legs"."dog_id" = 1</em>
   (0.1ms)  BEGIN
  SQL (0.3ms)  UPDATE "legs" SET "dog_id" = NULL WHERE "legs"."dog_id" = 1 AND "legs"."id" IN (10, 5)
   (0.2ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 2
   (0.2ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 9
   (0.6ms)  COMMIT
          </code></pre>

        </section>
        <!-- #29      img: many legs --><section>

          <img src="images/many_legs.jpg">

        </section>
        <!-- #30    dog.head.fix --><section>

          <h2>dog.head.fix</h2>

          <pre class="fragment"><code>unique.fix :db, diy: true, mysql: mysql?</code></pre>

        </section>
        <!-- #31    dog.fix :db --><section>

          <h3>dog.fix :db</h3>

          <pre class="fragment"><code class="ruby" data-trim>
headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
headless && Dog.transaction do
  headless.lock!
  headless.create_head
end
legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
legless && Dog.transaction do
  legless.lock!
  legless.legs = 4.times.map{ Leg.create }
end
          </code></pre>
          <pre class="fragment subst"><code class="ruby" data-noescape data-trim>
headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
headless && <em>Dog.transaction do</em>
  <em>headless.lock!</em>
  headless.create_head
end
legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
legless && <em>Dog.transaction do</em>
  <em>legless.lock!</em>
  legless.legs = 4.times.map{ Leg.create }
end
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
--- expected
+++ actual
@@ -1 +1 @@
-"50 dogs with 1 head and 4 legs"
+"30 dogs with 1 head and 4 legs, 11 dogs with 2 heads and 4 legs, 4 dogs with 3 heads and 4 legs, 4 dogs with 4 heads and 4 legs, 1 dog with 5 heads and 4 legs"
          </code></pre>

        </section>
        <!-- #32      img: car over water --><section>

          <img src="images/car_over_water.jpg">
          <!-- cc
            Courtesy of the Boston Public Library, Leslie Jones Collection
            http://www.flickr.com/photos/boston_public_library/5786875562/
          -->

        </section>
        <!-- #33    dog.refix(:db) --><section>

          <h3>dog.refix :db</h3>

          <pre class="fragment"><code class="sql" data-noescape data-trim>
> <em>Dog.first.create_head</em>
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (12.0ms)  <em>INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", 1]]</em>
   (0.9ms)  COMMIT
  Head Load (0.2ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1<em> </em>LIMIT 1
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 1
   (0.4ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> <em>Dog.first.head = Head.create</em>
  Dog Load (39.8ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (49.1ms)  INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", <em>nil</em>]]
   (0.6ms)  COMMIT
"replace"
  Head Load (0.4ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1 LIMIT 1
   (0.1ms)  BEGIN
   (0.4ms)  <em>UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 2</em>
   (0.2ms)  <em>UPDATE "heads" SET "dog_id" = 1 WHERE "heads"."id" = 3</em>
   (0.5ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="ruby" data-noescape data-trim>
headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
headless && Dog.transaction do
  headless.lock!
  <em>headless.head = Head.create</em>
end
legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
legless && Dog.transaction do
  legless.lock!
  legless.legs = 4.times.map{ Leg.create }
end
          </code></pre>

          <pre class="fragment"><code clss="no-highlight" data-trim>
# Running tests:

.

Finished tests in 2.527906s, 0.3956 tests/s, 0.7912 assertions/s.

1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
          </code></pre>
        </section>
        <!-- #34    dog.fix :diy --><section>

          <h3>dog.fix :diy</h3>

          <pre class="fragment w100"><code class="ruby" data-trim>
headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
if headless
  headless.create_head
  Head.update_all({ dog_id: nil },
    { id: Head.where(dog_id: headless.id).order(:id).pluck(:id)[0..-2] })
end
legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
if legless
  legless.legs = 4.times.map{ Leg.create }
  Leg.update_all({ dog_id: nil },
    { id: Leg.where(dog_id: legless.id).order(:id).pluck(:id)[0..-5] })
end
          </code></pre>
          <pre class="fragment w100 subst"><code class="ruby" data-noescape data-trim>
headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
if headless
  headless.create_head
  <em>Head.update_all({ dog_id: nil },</em>
    <em>{ id: Head.where(dog_id: headless.id).order(:id).pluck(:id)[0..-2] })</em>
end
legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
if legless
  legless.legs = 4.times.map{ Leg.create }
  <em>Leg.update_all({ dog_id: nil },</em>
    <em>{ id: Leg.where(dog_id: legless.id).order(:id).pluck(:id)[0..-5] })</em>
end
          </code></pre>
          <pre class="fragment w100 subst"><code class="ruby" data-noescape data-trim>
headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
if headless
  headless.create_head
  Head.update_all({ dog_id: nil },
    { id: Head.where(dog_id: headless.id).<em>order(:id)</em>.pluck(:id)<em>[0..-2]</em> })
end
legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
if legless
  legless.legs = 4.times.map{ Leg.create }
  Leg.update_all({ dog_id: nil },
    { id: Leg.where(dog_id: legless.id).<em>order(:id)</em>.pluck(:id)<em>[0..-5]</em> })
end
          </code></pre>

          <pre class="fragment"><code clss="no-highlight" data-trim>
# Running tests:

.

Finished tests in 2.957711s, 0.3956 tests/s, 0.7912 assertions/s.

1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
          </code></pre>

        </section>
        <!-- #35  Facet 3: Emigration --><section>
          <ul>
          <li><h4>Facet #1: One and Only</h4></li>
          <li><h4>Facet #2: I Can Haz One or Many?</h4></li>
          <li><h2>Facet #3: Emigration</h2></li>
          </ul>
        </section>
        <!-- #36    db:migrate --><section>

          <h3>db:migrate</h3>
          <ul>
            <li class="fragment">Add table - OK</li>
            <li class="fragment">Add column, add/remove index - so-so</li>
            <li class="fragment">Remove column - oops <span class="fragment">(before 4.0)</span></li>
          </ul>

        </section>
        <!-- #37    try :remove_column --><section>

          <h3>try :remove_column</h3>

          <pre class="fragment"><code class="ruby" data-trim>
remove_column :extra_columns, :extra
          </code></pre>

          <pre class="fragment"><code class="sql" data-trim>
> ExtraColumn.create
   (0.2ms)  BEGIN
  SQL (34.9ms)  INSERT INTO "extra_columns" ("extra", "value") VALUES ($1, $2) RETURNING "id"  [["extra", nil], ["value", nil]]
   (0.2ms)  ROLLBACK
ActiveRecord::StatementInvalid: PG::Error: ERROR:  column "extra" of relation "extra_columns" does not exist at character 30
: INSERT INTO "extra_columns" ("extra", "value") VALUES ($1, $2) RETURNING "id"
          </code></pre>
          <pre class="fragment subst"><code class="sql" data-trim data-noescape>
> ExtraColumn.create
   (0.2ms)  BEGIN
  SQL (34.9ms)  INSERT INTO "extra_columns" ("extra", "value") VALUES ($1, $2) RETURNING "id"  [["extra", nil], ["value", nil]]
   (0.2ms)  ROLLBACK
<em>ActiveRecord::StatementInvalid: PG::Error: ERROR:  column "extra" of relation "extra_columns" does not exist at character 30</em>
<em>: INSERT INTO "extra_columns" ("extra", "value") VALUES ($1, $2) RETURNING "id"</em>
          </code></pre>
            
        </section>
        <!-- #38      img: train crash --><section>

          <img src="images/rebels.jpg">
          <!-- cc
            PD A.J. Russell
            http://commons.wikimedia.org/wiki/File:A.J._Russell_(American_-_Railroad_Accident_Caused_by_Rebels_-_Google_Art_Project.jpg
          -->

        </section>
        <!-- #39    remove_column.inspect --><section>

          <h3>remove_column.inspect</h3>

          <pre class="fragment w100"><code class="ruby" data-trim>
def columns
  @columns ||= connection.schema_cache.columns[table_name].map do |col|
    col = col.dup
    col.primary = (col.name == primary_key)
    col
  end
end
          </code></pre>
          <ul>
            <li class="fragment">All operations are defined in terms of klass.columns (directly or indirectly)</li>
            <li class="fragment">True for Rails 2.x, 3.0 <img class= "fragment smallTop" src="images/gap.jpg"> 3.2</li>
          </ul>

        </section>
        <!-- #40    remove_column.fix --><section>

          <h3>remove_column.fix</h3>

          <ul>
            <pre class="fragment" style="width:100%;"><code class="ruby" data-trim data-noescape>
class ExtraColumn < ActiveRecord::Base
  def self.columns
    @my_columns ||= super.reject{&nbsp;|c|
      c.name == 'extra'
    }
  end
end
            </code></pre>
            <li class="fragment">Deploy</li>
            <pre class="fragment"><code class="ruby" data-trim>
remove_column :extra_columns, :extra
            </code></pre></li>
            <li class="fragment">Remove ExtraColumn.columns</li>
            <li class="fragment">Deploy</li>
          </ul>

        </section>
        <!-- #41    remove_column.fix :rails_3_1 --><section>

          <h3>remove_column.fix :rails_3_1</h3>

          <img src="images/3.1.jpg">

        </section>
        <!-- #42      img: car_on_car  --><section>

          <img src="images/car_on_car.jpg">
          <!-- cc
            Courtesy of the Boston Public Library, Leslie Jones Collection
            http://www.flickr.com/photos/boston_public_library/5786895180/
          -->

        </section>
        <!-- #43  Facet 4: Assets --><section>
          <ul>
            <li><h4>Facet #1: One and Only</h4> </li>
            <li><h4>Facet #2: I Can Haz One or Many?</h4></li>
            <li><h4>Facet #3: Emigration</h4></li>
            <li><h2>Facet #4: Assets & Liabilities</h2></li>
          </ul>

        </section>
        <!-- #44    deploy :shutdown --><section>
          <h3>deploy :shutdown</h3>
            <span>
              <img class="small" src="images/box_many_rails.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box.png">
              <img class="small" src="images/box.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box.png">
              <img class="small" src="images/box_many_rails_g.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box_many_rails_g.png">
              <img class="small" src="images/box_many_rails_g.png">
            </span>
        </section>
        <!-- #45    deploy :rolling_swap --><section>
          <h3>deploy :rolling_swap</h3>
            <span>
              <img class="small" src="images/box_many_rails.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box_many_rails_mix.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box_many_rails_g.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box_many_rails_g.png">
              <img class="small" src="images/box_many_rails_mix.png">
            </span>
        </section>
        <!-- #46    deploy :rolling_shutdown --><section>
          <h3>deploy :rolling_shutdown</h3>
            <span>
              <img class="small" src="images/box_many_rails.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box_many_rails_g.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
        </section>
        <!-- #47    rake assets:fix --><section>
          <h3>rake assets:fix</h3>
          <pre class="fragment"><code class="ruby" data-trim>
config.action_controller.asset_host = "//your.super.asset.host"
          </code></pre></li>
          <ul>
            <li class="fragment">For S3 you can use gem 'asset_sync'</li>
            <li class="fragment">... or roll out your own solution to upload precompiled assets before deployment</li>
            <li class="fragment">Do not delete old assets too early</li>
          </ul>
          <pre class="fragment"><code class="ruby" data-trim>
config.assets.digest = true
          </code></pre>
        </section>
        <!-- #48      img: fast  --><section>

          <img src="images/fast.jpg">
          <!-- cc
            CC-BY-SA 3.0 Bhanutpt
            http://commons.wikimedia.org/wiki/File:Fast_Moving_Train_India.jpg
          -->

        </section>
        <!-- #49  Rails.why? --><section>
          <h2>Rails.why?</h2>
          <div class="fragment">
            <blockquote cite="http://david.heinemeierhansson.com/2012/rails-is-omakase.html">
              Rails is omakase. A team of chefs picked out the ingredients, designed the APIs, and arranged the order
              of consumption on your behalf according to their idea of what would make for a tasty full-stack framework.
            </blockquote>
            <p class="author">DHH</p>
          </div>
          <small class="fragment">
            NOTICE: Consuming raw or undercooked meats, poultry, seafood, shellfish, or eggs may increase your risk
            of foodborne illness
          </small>
        </section>
        <!-- #50 Part 2. Off Rails --><section>

          <h2>Part 2</h2>
          <h3>Off Rails</h3>

        </section>
        <!-- #51  Development and Deployment --><section>
          <h3>Development and Deployment</h3>
          <div class="fragment">
            <blockquote cite="http://david.heinemeierhansson.com/2012/rails-is-omakase.html">
              Concurrency of development with deployment . . . has almost always proven counterproductive
            </blockquote>
            <p class="author">Harold Brown</p>
          </div>

        </section>
        <!-- #52    Call for volunteers --><section>
          <h3>Development and Deployment</h3>
          <img class="small" src="images/box_many_rails_g.png">
          <img class="small" src="images/box_many_rails.png">
          <img class="small" src="images/box_many_rails.png">
          <img class="small" src="images/box_many_rails.png">
          <img class="small" src="images/box_many_rails.png">
          <p class="fragment">I Can Haz Four Volunteers?</p>
        </section>
        <!-- #53    changed_feature.deploy! --><section>
          <h2>changed_feature.deploy!</h2>
          <ol>
            <li class="fragment">Teach old dog new tricks (but do not show them)</li>
            <li class="fragment">Teach new dog old tricks</li>
            <li class="fragment">Swap your dogs</li>
            <li class="fragment">Wait...</li>
            <li class="fragment">Now you can forget old tricks</li>
          </ol>
          <ul>
            <li class="fragment">
              Your website is an API server and a client at the same time (but client is behind!)
            </li>
            <li class="fragment">Treat changing features as a new API version</li>
          </ul>
        </section>
        <!-- #54 quiz recap --><section>

          <h3>
            You may not worry about concurrency if:
          </h3>
          <ul>
            <li class="fragment">You do not care</li>
            <li class="fragment">But if you do – worry, and you will (almost) always find your way</li>
          </ul>

        </section>
        <!-- #55   img: many ways  --><section>

          <img src="images/many_ways.jpg">
          <!-- cc
            CC BY-NC-ND 2.0 SCFiasco
            http://www.flickr.com/photos/scfiasco/4490322916/
          -->

        </section>
        <!-- #56 Bonus --><section>
          <h3>Homework</h3>
          <h4 class="fragment">Design a Presentation Web App</h4>
          <ul>
            <li class="fragment">User can add a slide at an arbitrary place</li>
            <li class="fragment">User can easily reorder slides</li>
            <li class="fragment">All edits are saved "behind the scenes"</li>
          <h4 class="fragment">Consider:</h4>
            <ul>
              <li class="fragment">Synchronous vs. asynchronous messaging</li>
              <li class="fragment">Lost slide reordering messages</li>
              <li class="fragment">Reordering messages coming out-of-order</li>
              <li class="fragment">User adding, editing and/or reordering on a stale page</li>
              <li class="fragment">Extra bonus: collaborative editing</li>
            </ul>
          </ul>
        </section>
        <!-- #57 credits --><section>
          <h4>Credits</h4>
          <ul class="tiny">
            <li>Hakim El Hattab - Reveal.js, http://lab.hakim.se/reveal-js/#/
            <li>"Concurrency." Merriam-Webster.com. Merriam-Webster, n.d. Web. 23 Aug. 2013. [http://www.merriam-webster.com/dictionary/concurrency]</li>
            <li>Wikipedia - http://en.wikipedia.org/wiki/Concurrency_(computer_science)</li>
            <li>David Heinemeier Hansson - http://david.heinemeierhansson.com/2012/rails-is-omakase.html</li>
            <li>Harold Brown - http://www.foreignaffairs.com/articles/40540/harold-brown/is-sdi-technically-feasible</li>

            <li>Images:</li>
            <ul>
              <li>Garrett Fitzgerald - http://commons.wikimedia.org/wiki/File:SeattleMonorailAccident.jpg</li>
              <li>SoRah42 - http://sorah42.deviantart.com/art/Unique-187278898</li>
              <li>http://commons.wikimedia.org/wiki/File:GuateQuake1976BentRailsA.jpg</li>
              <li>http://en.wikipedia.org/wiki/File:Train_wreck_at_Montparnasse_1895.jpg</li>
              <li>Courtesy of the Boston Public Library, Leslie Jones Collection:
                <ul>
                  <li>http://www.flickr.com/photos/boston_public_library/5786875562/</li>
                  <li>http://www.flickr.com/photos/boston_public_library/5786895180/</li>
                </ul>
              <li>John McNab - http://www.flickr.com/photos/johnmcnab/6511819727/</li>
              <li>Mike Campbell - http://www.flickr.com/photos/morphyoss/4963981594/</li>
              <li>Swansea - http://www.freefoto.com/download/23-22-1/Swansea-London-Paddington-High-Speed-Train--HST-</li>
              <li>http://commons.wikimedia.org/wiki/File:Loket_vid_j%C3%A4rnv%C3%A4gsolyckan_i_Get%C3%A5_1918.jpg</li>
              <li>A.J. Russell - http://commons.wikimedia.org/wiki/File:A.J._Russell_(American_-_Railroad_Accident_Caused_by_Rebels_-_Google_Art_Project.jpg</li>
              <li>Bhanutpt - http://commons.wikimedia.org/wiki/File:Fast_Moving_Train_India.jpg</li>
              <li>SCFiasco - http://www.flickr.com/photos/scfiasco/4490322916/</li>
            </ul>
          </ul>
        </section>
        <!-- #58 Q & A --><section>
          <h1>Q & A</h1>
        </section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: 'default', //Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'lib/js/fullscreen-img.js' }

					//{ src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
      Reveal.addEventListener( 'fragmentshown', function( event ) {
        if (event.fragment.className.match(/(?:^|\s)subst(?!\S)/)) {
          event.fragment.previousElementSibling.className += " hidden";
        } 
      });
      Reveal.addEventListener( 'fragmenthidden', function( event ) {
        if (event.fragment.className.match(/(?:^|\s)subst(?!\S)/)) {
          event.fragment.previousElementSibling.className = 
            event.fragment.previousElementSibling.className.replace( /(?:^|\s)hidden(?!\S)/g , '' );
        }
      });
      Reveal.addEventListener( 'slidechanged', function( event ) {
        // event.previousSlide, event.currentSlide, event.indexh, event.indexv
        var notes = event.currentSlide.querySelector(".notes");
        if(notes) {
          console.info(notes.innerHTML.replace(/\n\s+/g,'\n'));
        }
      } );
		</script>

	</body>
</html>
