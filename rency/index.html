<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Shadow Facets of Concurrency</title>

		<meta name="description" content="Reveal.js version of Shadow Facets of Concurrency prsentation">
		<meta name="author" content="Eugene Kalenkovich">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/serif.css" id="theme">
    <link rel="stylesheet" href="css/concur.css">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="css/github.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="reveal/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
        <!-- Rails: Shadow Facets of Concurrency --><section>

<aside class="notes" data-markdown>
Opening
</aside>
          <h2>Rails: Shadow Facets of Concurrency</h2>

          <small>
            <p align="right">
              Eugene Kalenkovich
            </p>
            <p align="right">
              <a href="http://twitter.com/UncleGene">@UncleGene</a>
            </p>
          </small>
          <br />
          <br />
          <br />
          <br />
          <pre align="right" class="w65"><code class="ruby" data-trim data-noescape>
audience.<em>except</em>(&:can_see_this).each do |person|
  # Please!
  person.move(:closer)
end
          </code></pre>
        </section>
        <!-- #1  You may not worry about concurrency if: --><section>

<aside class="notes" data-markdown>
Please raise your hand if you agree that you should not care about concurrency if

* you use rails?
* you use rails and ypu do not use multi-threading?
* rails, single thread, and low traffic?

You are not alone! | You are good, but...
</aside>
          <h2>
            You may not worry about concurrency if:
          </h2>
          <ul>
            <li class="fragment">You use Rails</li>
            <li class="fragment">Your application is single-threaded</li>
            <li class="fragment">You have a very low traffic</li>
          </ul>

        </section>
        <!-- #2    img: monorail --><section>

<aside class="notes" data-markdown>
Somebody felt safe with low-traffic single-threaded Rails application
</aside>
          <img src="images/SeattleMonorailAccident.jpg">
          <!-- cc 
            #CC-BY-SA-2.5 Garrett Fitzgerald
            #http://commons.wikimedia.org/wiki/File:SeattleMonorailAccident.jpg
          -->

        </section>
        <!-- #3  When? --><section>

<aside class="notes" data-markdown>
Let look at when concurrency may become an issue
</aside>

          <h2>When?</h2>

        </section>
        <!-- #4    RAILS_ENV=development --><section>

<aside class="notes" data-markdown>
When we develop our application, we use an environment where we always have
[at most] one rails instance. We have absolutely no chance to encounter any concurrency
issues when we run our rails server, rails console or test suite.

(BTW, everywhere in this talk I assume you use classic relational Rails stack.
If you use NoSQL, you probably just exchange one set of problems to another)

But as soon as we deploy our application to production environment  ...
</aside>

          <h3>RAILS_ENV=development</h3>
          <img class="small" src="images/box_one_rails_one_db.png">

        </section>
        <!-- #5    RAILS_ENV=production --><section>

<aside class="notes" data-markdown>
We are starting to be exposed to the first aspect of concurrency

- you have multiple Rails instances trying to talk to the same database
  (BTW, in this talk I assume you use classic relational Rails stack.
  If you use NoSQL, you probably just exchange one set of problems to another)
- and as soon as we start to scale, we have
- the aspect of unpredictable routing
  - you never know which host will reply to the request
  - or even in what order your hosts will reply
</aside>

          <h3>RAILS_ENV=production</h3>
          <div>
            <img class="small" src="images/box_many_rails.png">
            <img class="small" src="images/box_one_db.png">
          </div>
          <div class="fragment subst" data-fragment-index="2">
            <img class="small" src="images/box_many_rails.png">
            <img class="small" src="images/box_many_rails.png">
            <img class="small" src="images/box_one_db.png">
            <img class="small" src="images/box_many_rails.png">
            <img class="small" src="images/box_many_rails.png">
          </div>

          <ul>
            <li class="fragment" data-fragment-index="1">Shared resources
            <li class="fragment" data-fragment-index="3">Non-deterministic request processing
            <ul>
              <li class="fragment" data-fragment-index="4">Who
              <li class="fragment" data-fragment-index="5">When
            </ul>
          </ul>

          </section>
        <!-- #6 Part 1. Rails and Concurrency --><section>

<aside class="notes" data-markdown>
We'll start with looking at concurrency issues specific to Rails
</aside>

          <h2>Part 1</h2>
          <h3>Rails and Concurrency</h3>

        </section>
        <!-- #7    RAILS_ENV=test --><section>

<aside class="notes" data-markdown>
But let at first invest in a tool set that would allow to reproduce such issues 
and verify our attempts to fix them.

- First of all, we need to make sure that we use in test the same database engine
and adaptor as anywhere else. Default sqlite is useless for our purposes.
But please, PLEASE, make sure that the database name is different!
- second - we just need to add to our code a helper function that will simulate
the multi-process environment
  - we fork provided block of code to multiple processes
  - and make sure at the end that all processes succeed
</aside>

          <h3>RAILS_ENV=test</h3>
          <div class="fragment">
            database.yml:
            <pre class="w55"><code data-trim>
test:
  adapter: postgresql  # mysql2
  database: your_db_test
            </code></pre>
          </div>
          <div class="fragment">
            test_helper.rb (spec_helper.rb):
            <pre class="w80"><code class="ruby" data-trim>
def concurrently processes = 10
  processes.times do
    fork do
      yield
    end
  end
  assert Process.waitall.map(&:last).all? &:success?
end
            </code></pre>
            <pre class="fragment w80 subst"><code class="ruby" data-noescape data-trim>
def concurrently processes = 10
  processes.times do
    <em>fork do</em>
      <em>yield</em>
    <em>end</em>
  end
  assert Process.waitall.map(&:last).all? &:success?
end
            </code></pre>
            <pre class="fragment w80 subst"><code class="ruby" data-noescape data-trim>
def concurrently processes = 10
  processes.times do
    fork do
      yield
    end
  end
  <em>assert Process.waitall.map(&:last).all? &:success?</em>
end
            </code></pre>
          </div>
        </section>
        <!-- #8    RAILS_ENV=test --><section>

<aside class="notes" data-markdown>
In reality this is a little bit more involved. As we are testing for concurrency, we
need to handle all shared resources safely ourselves.

- we need to make sure that each of our processes has its own database connection
(fork creates an exact copy, so without this all processes will try to se the same connection)
- and we need to take care of another shared resource - IO.
Without this precaution all processes can try to output everything at once,
and good luck in trying to parse interleaved exception backtraces.
</aside>

          <h3>RAILS_ENV=test</h3>
          <pre class="w80"><code class="ruby" data-trim>
def concurrently processes = 10
  ActiveRecord::Base.remove_connection
  processes.times do
    fork do
      begin
        ActiveRecord::Base.establish_connection
        yield
      rescue => e
        puts "#{e.class.name}: #{e}" && exit 1
      ensure
        ActiveRecord::Base.remove_connection
      end
    end
  end
  ActiveRecord::Base.establish_connection
  assert Process.waitall.map(&:last).all? &:success?
end  
          </code></pre>

          <pre class="fragment w80 subst"><code class="ruby" data-noescape data-trim>
def concurrently processes = 10
  <em>ActiveRecord::Base.remove_connection</em>
  processes.times do
    fork do
      begin
        <em>ActiveRecord::Base.establish_connection</em>
        yield
      rescue => e
        puts "#{e.class.name}: #{e}" && exit 1
      ensure
        <em>ActiveRecord::Base.remove_connection</em>
      end
    end
  end
  <em>ActiveRecord::Base.establish_connection</em>
  assert Process.waitall.map(&:last).all? &:success?
end
          </code></pre>

          <pre class="fragment w80 subst"><code class="ruby" data-noescape data-trim>
def concurrently processes = 10
  ActiveRecord::Base.remove_connection
  processes.times do
    fork do
      begin
        ActiveRecord::Base.establish_connection
        yield
      <em>rescue => e</em>
        <em>puts "#{e.class.name}: #{e}" && exit 1</em>
      ensure
        ActiveRecord::Base.remove_connection
      end
    end
  end
  ActiveRecord::Base.establish_connection
  assert Process.waitall.map(&:last).all? &:success?
end
          </code></pre>

        </section>
        <!-- #9  Facet #1: One and Only --><section>

<aside class="notes" data-markdown>
Now we are ready to start digging. Our first facet is One and Only - you do not want users in your model  to
share the same social, or cars to have the same VIN (unless you are working on a counterfeit application)?

Rails gives us at least two ways to do this.

And the first of them is...
</aside>

          <h2>Facet #1: One and Only</h2>
          <img src="images/unique_by_sorah42-d33i1bm.jpg">
          <!-- cc 
            cc by-sa 3.0 SoRah42
            http://sorah42.deviantart.com/art/Unique-187278898
          -->


        </section>
        <!-- #10    first_or_create --><section>

<aside class="notes" data-markdown>
first_or_create (or its now deprecated twin find_or_create_by)

- To test this we'll create a simple model Number with a single attribute
conveniently called value.
- and to exercise this approach we have a simple test
  - that creates a number with a value corresponding to current database state.
    
    We want our test processes to collide as much as possible, and Number.count is used
as a simple synchronization mechanism

  - at the end we check that all values are unique by comparing number of records
with number of unique values

- Let run this test, and we see that 50 numbers (99 - 49) have non-unique values
</aside>

          <h3>first_or_create</h3>
          <pre class="fragment"><code class="ruby" data-trim>
class Number < ActiveRecord::Base
  # t.integer :value
end   
          </code></pre>

          <pre class="fragment"><code class="ruby" data-noescape data-trim>
describe Number do
  it 'should have unique values' do
    concurrently do
      10.times do
        Number.where(value: Number.count).first_or_create
      end
    end
    Number.count.must_equal Number.select('distinct value').count
  end
end
          </code></pre>
          <pre class="fragment subst"><code class="ruby" data-noescape data-trim>
describe Number do
  it 'should have unique values' do
    concurrently do
      10.times do
        <em>Number.where(value: Number.count).first_or_create</em>
      end
    end
    Number.count.must_equal Number.select('distinct value').count
  end
end
          </code></pre>
          <pre class="fragment subst"><code class="ruby" data-noescape data-trim>
describe Number do
  it 'should have unique values' do
    concurrently do
      10.times do
        Number.where(value: Number.count).first_or_create
      end
    end
    <em>Number.count.must_equal Number.select('distinct value').count</em>
  end
end
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
1) Failure:
test_0001_should_have_unique_values(Number) :
Expected: 49
  Actual: 99
          </code></pre>

        </section>
        <!-- #11      img: train over wall --><section>

<aside class="notes" data-markdown>
so - you have to change your code first to avoid such problems
</aside>

          <img src="images/santa_fe.jpg">
          <!-- cc
            CC BY-NC-SA 2.0 John McNab
            http://www.flickr.com/photos/johnmcnab/6511819727/
          -->

        </section>
        <!-- #12    first_or_create.inspect --><section>

<aside class="notes" data-markdown>
One of the best tools Rails provides to see what really happens is a query log
in Rails console

- Let see what happens. Rails really does what it says - first or create
  - It checks if record exists,
  - and creates a new one if it doesn't
  - second process comes in
  - finds the record and returns it.
- Everything works fine if these processes come one by one. But what can happen
if they come together?
  - First process: check!
  - Second process: check!
  - First process: I have to create!
  - Second: but I do too!
</aside>

          <h3>first_or_create.inspect</h3>
          <div>
            <pre class="fragment" data-fragment-index="1"><code class="sql" data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
   (0.2ms)  BEGIN
  SQL (9.0ms)  INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]
   (0.4ms)  COMMIT
            </code></pre>
            <pre class="fragment subst" data-fragment-index="2"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  <em>SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1</em>
   (0.2ms)  BEGIN
  SQL (9.0ms)  INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]
   (0.4ms)  COMMIT
            </code></pre>
            <pre class="fragment subst" data-fragment-index="3"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
   (0.2ms)  BEGIN
  SQL (9.0ms)  <em>INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]</em>
   (0.4ms)  COMMIT
            </code></pre>

            <pre class="fragment" data-fragment-index="4"><code class="sql" data-trim>
> Number.where(value: 3).first_or_create
  Number Load (0.4ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
            </code></pre>
            <pre class="fragment subst" data-fragment-index="5"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (0.4ms)  <em>SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1</em>
            </code></pre>
          </div>

          <div class="fragment subst" data-fragment-index="6">
            <pre><code class="sql" data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
   (0.2ms)  BEGIN
  SQL (9.0ms)  INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]
   (0.4ms)  COMMIT
            </code></pre>
            <pre class="fragment subst" data-fragment-index="7"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  <em>SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1</em>
   (0.2ms)  BEGIN
  SQL (9.0ms)  INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]
   (0.4ms)  COMMIT
            </code></pre>
            <pre class="fragment subst" data-fragment-index="9"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (16.2ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
   (0.2ms)  BEGIN
  SQL (9.0ms)  <em>INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]</em>
   (0.4ms)  COMMIT
            </code></pre>

            <pre><code class="sql" data-trim>
> Number.where(value: 3).first_or_create
  Number Load (0.4ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
            </code></pre>
            <pre class="fragment subst" data-fragment-index="8"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (0.4ms)  <em>SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1</em>
            </code></pre>
            <pre class="fragment subst" data-fragment-index="10"><code class="sql" data-noescape data-trim>
> Number.where(value: 3).first_or_create
  Number Load (0.4ms)  SELECT "numbers".* FROM "numbers" WHERE "numbers"."value" = 3 LIMIT 1
   (0.2ms)  BEGIN
  SQL (0.3ms)  <em>INSERT INTO "numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 3]]</em>
   (0.5ms)  COMMIT
            </code></pre>
          </div>


        </section>
        <!-- $13    validates :uniquiness --><section>

<aside class="notes" data-markdown>
The second tool Rails gives us - uniquiness validation

- We'll use another model that validates the value for uniquiness
- run practically the same test
- and get 59 non-unique values
- because underneath we do exactly the same,
  - just slightly different form of the query
</aside>

            <h3>validates :uniquiness</h3>

            <pre class="fragment"><code class="ruby" data-trim>
class ValidatedNumber < ActiveRecord::Base
  validates :value, uniqueness: true
end
            </code></pre>

            <pre class="fragment"><code class="ruby" data-trim>
describe ValidatedNumber do
  it 'should have unique values' do
    concurrently do
      10.times do
        ValidatedNumber.create{|r| r.value = ValidatedNumber.count}
      end
    end
    unique = ValidatedNumber.select("distinct value").count
    ValidatedNumber.count.must_equal unique
  end
end
            </code></pre>

<pre class="fragment"><code class="no-highlight">
1) Failure:
test_0001_should_have_unique_values(ValidatedNumber):
Expected: 37
  Actual: 96

            </code></pre>

            <pre class="fragment subst"><code class="sql" data-trim>
> ValidatedNumber.create(value: 1)
   (0.1ms)  BEGIN
  ValidatedNumber Exists (25.2ms)  SELECT 1 AS one FROM "validated_numbers" WHERE "validated_numbers"."value" = 1 LIMIT 1
  SQL (14.7ms)  INSERT INTO "validated_numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 1]]
   (0.7ms)  COMMIT
            </code></pre>
            <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> ValidatedNumber.create(value: 1)
   (0.1ms)  BEGIN
  ValidatedNumber Exists (25.2ms)  <em>SELECT 1 AS one FROM "validated_numbers" WHERE "validated_numbers"."value" = 1 LIMIT 1</em>
  SQL (14.7ms)  INSERT INTO "validated_numbers" ("value") VALUES ($1) RETURNING "id"  [["value", 1]]
   (0.7ms)  COMMIT
          </code></pre>

        </section>
        <!-- #14      img: train wreck --><section>

<aside class="notes" data-markdown>
and we get what we get!
</aside>

            <img src="images/Train_wreck_at_Montparnasse_1895.jpg">
            <!-- cc
                PD
                http://en.wikipedia.org/wiki/File:Train_wreck_at_Montparnasse_1895.jpg
            -->

        </section>
        <!-- #15    unique.fix :db  --><section>

<aside class="notes" data-markdown>
The way to fix this is to do validation at the only place that knows about all your processes -
on database level.

- The most universal way to do this is to add an
  - unique index on the column.

    Unfortunately this is not enough - if you do not change your application code, 

- what you get ia a bunch of exceptions;
- this is the case where you can start appreciating that we "abbreviated" errors  in our
helper method.
</aside>

          <h3>unique.fix :db </h3>

          <pre class="fragment"><code class="ruby" data-trim>
class CreateConstrainedNumbers < ActiveRecord::Migration
  def change
    create_table :constrained_numbers do |t|
      t.integer :value
    end
    add_index :constrained_numbers, :value, unique: true
  end
end
          </code></pre>

          <pre class="fragment subst"><code class="ruby" data-trim data-noescape>
class CreateConstrainedNumbers < ActiveRecord::Migration
  def change
    create_table :constrained_numbers do |t|
      t.integer :value
    end
    <em>add_index :constrained_numbers, :value, unique: true</em>
  end
end
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
# Running tests:

ActiveRecord::RecordNotUnique: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
ActiveRecord::RecordNotUnique: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
ActiveRecord::RecordNotUnique: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
ActiveRecord::RecordNotUnique: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
ActiveRecord::RecordNotUnique: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
[...]
          </code></pre>

          <pre class="fragment subst"><code class="no-highlight" data-noescape data-trim>
# Running tests:

<em>ActiveRecord::RecordNotUnique</em>: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
<em>ActiveRecord::RecordNotUnique</em>: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
<em>ActiveRecord::RecordNotUnique</em>: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
<em>ActiveRecord::RecordNotUnique</em>: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
<em>ActiveRecord::RecordNotUnique</em>: PG::Error: ERROR:  duplicate key value violates unique constraint "index_constrained_numbers_on_value"
DETAIL:  Key (value)=(0) already exists.
: INSERT INTO "constrained_numbers" ("value") VALUES ($1) RETURNING "id"
[...]
          </code></pre>

        </section>
        <!-- #16      img: quake bent rails --><section>

<aside class="notes" data-markdown>
We need to solve this problem ourselves...
</aside>

          <img src="images/GuateQuake1976BentRailsA.jpg">
          <!-- cc
            Public Domain
            http://commons.wikimedia.org/wiki/File:GuateQuake1976BentRailsA.jpg
          -->

        </section>
        <!-- #17    unique.fix :db, diy: true --><section>

<aside class="notes" data-markdown>
Instead of direct usage of first_or_create we'll need to

- wrap it in a custom method that handles RecordNotFound exception
  - by simply retrying the main flow.

Let run the test and make sure that everything is fine.

- And it is indeed.

  Or not...

  This works fine for Postgres. If we run the same code on MySQL

- we can get a nasty surprise. This surprise is a multi-layer one:
  - first, how MySQL manages to get to a deadlock performing
    the same operation? And second, why the adapter maps this to StatementInvalid exception -
    one that we can't blindly catch, as it can indicate real query problems.
</aside>

          <h3>unique.fix :db, diy: true</h3>

          <pre class="fragment"><code class="ruby" data-trim>
class SafeNumber < ActiveRecord::Base
  def self.first_or_create_where(*args)
    where(*args).first_or_create
  rescue ActiveRecord::RecordNotUnique
    retry
  end
end
          </code></pre>
          <pre class="fragment subst"><code class="ruby" data-noescape data-trim>
class SafeNumber < ActiveRecord::Base
  def self.first_or_create_where(*args)
    where(*args).first_or_create
  <em>rescue ActiveRecord::RecordNotUnique</em>
    <em>retry</em>
  end
end
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
# Running tests:

.

Finished tests in 8.337332s, 0.1199 tests/s, 0.2399 assertions/s.

1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
          </code></pre>

          <pre class="fragment"><code class="sql" data-trim>
ActiveRecord::StatementInvalid: Mysql2::Error: Deadlock found when trying to get lock; try restarting transaction: INSERT INTO `safe_numbers` (`value`) VALUES (132)
ActiveRecord::StatementInvalid: Mysql2::Error: Deadlock found when trying to get lock; try restarting transaction: INSERT INTO `safe_numbers` (`value`) VALUES (132)
F
          </code></pre>
          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
<em>ActiveRecord::StatementInvalid</em>: Mysql2::Error: <em>Deadlock found</em> when trying to get lock; try restarting transaction: INSERT INTO `safe_numbers` (`value`) VALUES (132)
<em>ActiveRecord::StatementInvalid</em>: Mysql2::Error: <em>Deadlock found</em> when trying to get lock; try restarting transaction: INSERT INTO `safe_numbers` (`value`) VALUES (132)
F
          </code></pre>

        </section>
        <!-- #18      img: curved rails --><section>

<aside class="notes" data-markdown>
We thought we straightened everything up, but..
</aside>

          <img src="images/4963981594_849491e7cc_o.jpg">
          <!-- cc
            CC BY-ND 2.0 Mike Campbell
            http://www.flickr.com/photos/morphyoss/4963981594/
          -->

        </section>
        <!-- #19    unique.fix :db, diy: true, mysql: true --><section>

<aside class="notes" data-markdown>
Here is our MySQL-specific wrapper
- We have a second rescue block in our method
- Where we have to look inside the message to see whether to retry or rethrow the exception (as our statement may
  really be invalid)
- Finally we get this working!
</aside>

          <h3>unique.fix :db, diy: true, mysql: true</h3>

          <pre class="fragment"><code class="ruby" data-trim>
def self.first_or_create_where(*args)
  where(*args).first_or_create
rescue ActiveRecord::RecordNotUnique
  retry
rescue ActiveRecord::StatementInvalid => e
  retry if e.message =~ /Deadlock/
  # Thank you, MySQL and Mysql2!
  raise
end
          </code></pre>
          <pre class="fragment subst"><code class="ruby" data-trim data-noescape>
def self.first_or_create_where(*args)
  where(*args).first_or_create
rescue ActiveRecord::RecordNotUnique
  retry
<em>rescue ActiveRecord::StatementInvalid => e</em>
  <em>retry if e.message =~ /Deadlock/</em>
  <em># Thank you, MySQL and Mysql2!</em>
  <em>raise</em>
end
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
# Running tests:

.

Finished tests in 3.234423s, 0.3092 tests/s, 0.6183 assertions/s.

1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
          </code></pre>

        </section>
        <!-- #20      img: fast train --><section>

<aside class="notes" data-markdown>
Hurray! We are moving forward!
</aside>

          <img src="images/fast_train.jpg">
          <!-- cc
            CC-BY-NC-ND 3.0 Swansea
            http://www.freefoto.com/download/23-22-1/Swansea-London-Paddington-High-Speed-Train- -->

        </section>
        <!-- #21  Facet #2: I Can Haz One or Many? --><section>

<aside class="notes" data-markdown>
The second facet we are going to look at is associated with associations
</aside>

          <ul>
            <li><h4>Facet #1: One and Only</h4></li>
            <li>
              <h2>Facet #2:<br/>I Can Haz One or Many?</h2>
              <h3>or Guilty by Association</h3>
            </li>
          </ul>

        </section>
        <!-- #22    class Dog --><section>

<aside class="notes" data-markdown>
To look at it let create a very practical and useful example.

- We'll try to build some dogs. Each of them will have one head and many legs. Sorry, Rails does not have has_four.
  Perhaps it has some reasons.
- And we'll have corresponding models for heads and legs
</aside>

          <h3>class Dog</h3>

          <pre class="fragment w55"><code class="ruby" data-trim>
class Dog < ActiveRecord::Base
  has_one :head
  has_many :legs
end
          </code></pre>

          <pre class="fragment w55"><code class="ruby" data-trim>
class Head < ActiveRecord::Base
  belongs_to :dog
end

class Leg < ActiveRecord::Base
  belongs_to :dog
end
          </code></pre>

        </section>
        <!-- #23    Dog.build --><section>

<aside class="notes" data-markdown>
And now - let build some dogs.

- At first we'll create 20 dogs (sorry, no heads or legs)
- We'll find a dog without a head, and fix this problem
- We'll do the same to help the dog move around
</aside>

          <h3>Dog.build</h3>

          <pre><code class="ruby" data-trim>
20.times{ Dog.create }

concurrently do
  begin
    headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
    headless && headless.create_head

    legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
    legless && legless.legs = 4.times.map{ Leg.create }
  end while headless || legless
end
          </code></pre>

          <pre class="fragment subst"><code class="ruby" data-trim data-noescape>
<em>20.times{ Dog.create }</em>

concurrently do
  begin
    headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
    headless && headless.create_head

    legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
    legless && legless.legs = 4.times.map{ Leg.create }
  end while headless || legless
end
          </code></pre>

          <pre class="fragment subst"><code class="ruby" data-trim data-noescape>
20.times{ Dog.create }

concurrently do
  begin
    <em>headless = Dog.includes(:head).where(heads: {dog_id: nil}).first</em>
    <em>headless && headless.create_head</em>

    legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
    legless && legless.legs = 4.times.map{ Leg.create }
  end while headless || legless
end
          </code></pre>

          <pre class="fragment subst"><code class="ruby" data-trim data-noescape>
20.times{ Dog.create }

concurrently do
  begin
    headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
    headless && headless.create_head

    <em>legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first</em>
    <em>legless && legless.legs = 4.times.map{ Leg.create }</em>
  end while headless || legless
end
          </code></pre>

        </section>
        <!-- #24    assert_sanity --><section>

<aside class="notes" data-markdown>
To verify what we get I used a helper method pretty_report that just constructs a human-readable description, and
  we compare it with the expected result. What is your guess for how many combinations we will get?

- Out of 20 dogs we got only one normal, and 15 different types of monsters.

</aside>

          <h3>assert_sanity</h3>

          <pre><code class="ruby" data-trim>
pretty_report(Dog.all).must_equal "20 dogs with 1 head and 4 legs"
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
--- expected
+++ actual
@@ -1 +1 @@
-"20 dogs with 1 head and 4 legs"
+"3 dogs with 1 head and 8 legs, 2 dogs with 2 heads and 28 legs, 2 dogs with 1 head and 12 legs, 1 dog with 1 head and 4 legs, 1 dog with 4 heads and 24 legs, 1 dog with 4 heads and 32 legs, 1 dog with 3 heads and 16 legs, 1 dog with 2 heads and 32 legs, 1 dog with 1 head and 16 legs, 1 dog with 6 heads and 8 legs, 1 dog with 1 head and 20 legs, 1 dog with 2 heads and 16 legs, 1 dog with 4 heads and 36 legs, 1 dog with 5 heads and 24 legs, 1 dog with 8 heads and 20 legs, 1 dog with 2 heads and 40 legs"
          </code></pre>
          <pre class="fragment subst"><code class="no-highlight" data-trim data-noescape>
--- expected
+++ actual
@@ -1 +1 @@
-"20 dogs with 1 head and 4 legs"
+"3 dogs with 1 head and 8 legs, 2 dogs with 2 heads and 28 legs, 2 dogs with 1 head and 12 legs, <em>1 dog with 1 head and 4 legs</em>, 1 dog with 4 heads and 24 legs, 1 dog with 4 heads and 32 legs, 1 dog with 3 heads and 16 legs, 1 dog with 2 heads and 32 legs, 1 dog with 1 head and 16 legs, 1 dog with 6 heads and 8 legs, 1 dog with 1 head and 20 legs, 1 dog with 2 heads and 16 legs, 1 dog with 4 heads and 36 legs, 1 dog with 5 heads and 24 legs, 1 dog with 8 heads and 20 legs, 1 dog with 2 heads and 40 legs"
          </code></pre>

        </section>
        <!-- #25      img: crash --><section>

<aside class="notes" data-markdown>
If you look carefully, the normal one managed to escape this accident
</aside>

          <img src="images/crash.jpg">
          <!-- cc
            PD
            http://commons.wikimedia.org/wiki/File:Loket_vid_j%C3%A4rnv%C3%A4gsolyckan_i_Get%C3%A5_1918.jpg
          -->

        </section>
        <!-- #26    dog.head.inspect --><section>

<aside class="notes" data-markdown>
What happens with heads?

- let use our handy inspection tool. We can see here not 1, but 4 problems:
  - First - new head is always added to a dog, By this Rails practically guarantees
    that in cases when you substitute has_one association, there is a period of time
    where has_one constraint is violated - you guaranteed to have 2 associations.
  - Second - what we already saw in uniquiness, select happening before update
  - Third - Rails believes that we had at most one association before
  - And fourth (hope you can see tiny highlight) is what is not there. This statement
    does not ask for any order. No database that I am aware of guarantees **any** order
    unless explicitly asked. It means that when DB decides to change the order - this
    detection of "if there was anything before" fails.
</aside>

          <h3>dog.head.inspect</h3>

          <pre class="fragment"><code class="sql" data-trim>
> Dog.first.create_head
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (12.0ms)  INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", 1]]
   (0.9ms)  COMMIT
  Head Load (0.2ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1 LIMIT 1
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 1
   (0.4ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> Dog.first.create_head
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (12.0ms)  <em>INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", 1]]</em>
   (0.9ms)  COMMIT
  Head Load (0.2ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1 LIMIT 1
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 1
   (0.4ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> Dog.first.create_head
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (12.0ms)  INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", 1]]
   (0.9ms)  COMMIT
  Head Load (0.2ms)  <em>SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1 LIMIT 1</em>
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 1
   (0.4ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> Dog.first.create_head
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (12.0ms)  INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", 1]]
   (0.9ms)  COMMIT
  Head Load (0.2ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1 <em>LIMIT 1</em>
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 1
   (0.4ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> Dog.first.create_head
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
   (0.1ms)  BEGIN
  SQL (12.0ms)  INSERT INTO "heads" ("dog_id") VALUES ($1) RETURNING "id"  [["dog_id", 1]]
   (0.9ms)  COMMIT
  Head Load (0.2ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" = 1<em> </em>LIMIT 1
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "heads" SET "dog_id" = NULL WHERE "heads"."id" = 1
   (0.4ms)  COMMIT
          </code></pre>

        </section>
        <!-- #27      img: many heads --><section>

<aside class="notes" data-markdown>
Hello multi-headed monsters!
</aside>
          <img src="images/three_heads.jpg">

        </section>
        <!-- #28    dog.legs.inspect --><section>

<aside class="notes" data-markdown>
Let look at what happens with legs

- When dog does not have any legs, all new legs are getting attached 
- If it had some before, rails first detaches ones that it does not need, and
  attaches only necessary new ones (skipping already attached)
- But we still have the same basic problem - select before update
</aside>

          <h3>dog.legs.inspect</h3>

          <pre class="fragment"><code class="sql" data-trim>
>   Dog.first.legs = Leg.all.sample(4)
  Dog Load (0.3ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
  Leg Load (0.2ms)  SELECT "legs".* FROM "legs"
  Leg Load (0.3ms)  SELECT "legs".* FROM "legs" WHERE "legs"."dog_id" = 1
   (0.1ms)  BEGIN
   (0.2ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 6
   (0.2ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 3
   (0.2ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 10
   (0.1ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 5
   (0.5ms)  COMMIT
          </code></pre>

          <pre class="fragment"><code class="sql" data-noescape data-trim>
> Dog.first.legs = Leg.all.sample(4)
  Dog Load (0.4ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
  Leg Load (0.3ms)  SELECT "legs".* FROM "legs"
  Leg Load (0.3ms)  SELECT "legs".* FROM "legs" WHERE "legs"."dog_id" = 1
   (0.1ms)  BEGIN
  SQL (0.3ms)  <em>UPDATE "legs" SET "dog_id" = NULL WHERE "legs"."dog_id" = 1 AND "legs"."id" IN (10, 5)</em>
   (0.2ms)  <em>UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 2</em>
   (0.2ms)  <em>UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 9</em>
   (0.6ms)  COMMIT
          </code></pre>

          <pre class="fragment subst"><code class="sql" data-noescape data-trim>
> Dog.first.legs = Leg.all.sample(4)
  Dog Load (0.4ms)  SELECT "dogs".* FROM "dogs" LIMIT 1
  Leg Load (0.3ms)  SELECT "legs".* FROM "legs"
  Leg Load (0.3ms)  <em>SELECT "legs".* FROM "legs" WHERE "legs"."dog_id" = 1</em>
   (0.1ms)  BEGIN
  SQL (0.3ms)  UPDATE "legs" SET "dog_id" = NULL WHERE "legs"."dog_id" = 1 AND "legs"."id" IN (10, 5)
   (0.2ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 2
   (0.2ms)  UPDATE "legs" SET "dog_id" = 1 WHERE "legs"."id" = 9
   (0.6ms)  COMMIT
          </code></pre>

        </section>
        <!-- #29      img: many legs --><section>

<aside class="notes" data-markdown>
that leads us to the similar problem
</aside>

          <img src="images/many_legs.jpg">

        </section>
        <!-- #30    dog.head.fix --><section>

<aside class="notes" data-markdown>
Simplest way is to use what we already know.

- As we have only one head, we can use the same approach as we used with uniquiness.
  If we really want, we can do it for legs too, making our dog have one front left leg, one front right, etc.
</aside>

          <h2>dog.head.fix</h2>

          <pre class="fragment"><code>unique.fix :db, diy: true, mysql: mysql?</code></pre>

        </section>
        <!-- #31    dog.fix :db --><section>

<aside class="notes" data-markdown>
But we may want to look at more universal solution. We are going to use database again.

- We will use database-level locking to prevent processes clashing into each other.
  - for this we will start transaction and lock the record right after finding it. Note that we are locking the
    "parent" record, even though we are not going to update it.
- We run our tests and can see that solution works. But we already saw that behavior can be database-specific.
- This time - you enjoy it only with MySQL. Postgres uses its right to return arbitrary record,
  and we still have problem with heads.
</aside>

          <h3>dog.fix :db</h3>

          <pre class="fragment"><code class="ruby" data-trim>
headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
headless && Dog.transaction do
  headless.lock!
  headless.create_head
end
legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
legless && Dog.transaction do
  legless.lock!
  legless.legs = 4.times.map{ Leg.create }
end
          </code></pre>
          <pre class="fragment subst"><code class="ruby" data-noescape data-trim>
headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
headless && <em>Dog.transaction do</em>
  <em>headless.lock!</em>
  headless.create_head
end
legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
legless && <em>Dog.transaction do</em>
  <em>legless.lock!</em>
  legless.legs = 4.times.map{ Leg.create }
end
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
          </code></pre>

          <pre class="fragment"><code class="no-highlight" data-trim>
--- expected
+++ actual
@@ -1 +1 @@
-"50 dogs with 1 head and 4 legs"
+"30 dogs with 1 head and 4 legs, 11 dogs with 2 heads and 4 legs, 4 dogs with 3 heads and 4 legs, 4 dogs with 4 heads and 4 legs, 1 dog with 5 heads and 4 legs"
          </code></pre>

        </section>
        <!-- #32      img: car over water --><section>

<aside class="notes" data-markdown>
Rails 4 fixed the implicit ordering problem, but for Postgres on with other versions we need to keep looking
</aside>

          <img src="images/car_over_water.jpg">
          <!-- cc
            Courtesy of the Boston Public Library, Leslie Jones Collection
            http://www.flickr.com/photos/boston_public_library/5786875562/
          -->

        </section>
        <!-- #33    dog.fix :db, force(:brute) --><section>

<aside class="notes" data-markdown>
We can do it the hard way

- We will use this lock upfront
- And indeed, we have all our tests succeeding.
- But the cost of this may be pretty high:
  - This is not even table lock, it is a select for update of all records you have
  - You need to pay attention to how class-level lock works. If you do not have any narrowing or limiting clauses,
  it will always lock all records.
</aside>

          <h3>dog.fix :db, force(:brute)</h3>

          <pre class="fragment"><code class="ruby" data-trim>
headless, legless = nil, nil
Dog.transaction do
  headless = Dog.lock.includes(:head).reject(&:head).first
  headless && headless.create_head
end
Dog.transaction do
  legless = Dog.lock.includes(:legs).select{|d| d.legs.empty?}.first
  legless && legless.legs = 4.times.map{ Leg.create }
end
          </code></pre>
          <pre class="fragment subst" data-fragment-index="4"><code class="ruby" data-noescape data-trim>
headless, legless = nil, nil
Dog.transaction do
  headless = <em>Dog.lock.includes(:head)</em>.reject(&:head).first
  headless && headless.create_head
end
Dog.transaction do
  legless = <em>Dog.lock.includes(:legs)</em>.select{|d| d.legs.empty?}.first
  legless && legless.legs = 4.times.map{ Leg.create }
end
          </code></pre>

          <pre class="fragment" data-fragment-index="1"><code clss="no-highlight" data-trim>
# Running tests:

.

Finished tests in 2.527906s, 0.3956 tests/s, 0.7912 assertions/s.

1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
          </code></pre>
          <pre class="fragment" data-fragment-index="2"><code class="sql" data-trim>
> Dog.lock.includes(:head).reject(&:head).first
  Dog Load (1.1ms)  SELECT "dogs".* FROM "dogs" FOR UPDATE
  Head Load (0.3ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
          </code></pre>
          <pre class="fragment subst" data-fragment-index="3"><code class="sql" data-trim data-noescape>
> Dog.lock.includes(:head).reject(&:head).first
  Dog Load (1.1ms)  <em>SELECT "dogs".* FROM "dogs" FOR UPDATE</em>
  Head Load (0.3ms)  SELECT "heads".* FROM "heads" WHERE "heads"."dog_id" IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
          </code></pre>

        </section>
        <!-- #34    dog.fix :diy --><section>

<aside class="notes" data-markdown>
As we probably do not want to use this sledgehammer, let fix it ourselves.

- We are going to do a cleanup **after** update
  - For this we will do decapitation and amputation manually at the end
  - The key part here is that all processes have to agree what to remove.
    They should not be greedy and try to preserve what they just have added.
- And tests confirm for us that the cleanup approach succeeds

</aside>

          <h3>dog.fix :diy</h3>

          <pre class="fragment w100"><code class="ruby" data-trim>
headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
if headless
  headless.create_head
  Head.update_all({ dog_id: nil },
    { id: Head.where(dog_id: headless.id).order(:id).pluck(:id)[0..-2] })
end
legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
if legless
  legless.legs = 4.times.map{ Leg.create }
  Leg.update_all({ dog_id: nil },
    { id: Leg.where(dog_id: legless.id).order(:id).pluck(:id)[0..-5] })
end
          </code></pre>
          <pre class="fragment w100 subst"><code class="ruby" data-noescape data-trim>
headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
if headless
  headless.create_head
  <em>Head.update_all({ dog_id: nil },</em>
    <em>{ id: Head.where(dog_id: headless.id).order(:id).pluck(:id)[0..-2] })</em>
end
legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
if legless
  legless.legs = 4.times.map{ Leg.create }
  <em>Leg.update_all({ dog_id: nil },</em>
    <em>{ id: Leg.where(dog_id: legless.id).order(:id).pluck(:id)[0..-5] })</em>
end
          </code></pre>
          <pre class="fragment w100 subst"><code class="ruby" data-noescape data-trim>
headless = Dog.includes(:head).where(heads: {dog_id: nil}).first
if headless
  headless.create_head
  Head.update_all({ dog_id: nil },
    { id: Head.where(dog_id: headless.id).<em>order(:id)</em>.pluck(:id)<em>[0..-2]</em> })
end
legless = Dog.includes(:legs).where(legs: {dog_id: nil}).first
if legless
  legless.legs = 4.times.map{ Leg.create }
  Leg.update_all({ dog_id: nil },
    { id: Leg.where(dog_id: legless.id).<em>order(:id)</em>.pluck(:id)<em>[0..-5]</em> })
end
          </code></pre>

          <pre class="fragment"><code clss="no-highlight" data-trim>
# Running tests:

.

Finished tests in 2.957711s, 0.3956 tests/s, 0.7912 assertions/s.

1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
          </code></pre>

        </section>
        <!-- #35  Facet 3: Emigration --><section>

<aside class="notes" data-markdown>
Facet 3: Emigration
</aside>
          <ul>
          <li><h4>Facet #1: One and Only</h4></li>
          <li><h4>Facet #2: I Can Haz One or Many?</h4></li>
          <li><h2>Facet #3: Emigration</h2></li>
          </ul>
        </section>
        <!-- #36    db:migrate --><section>

<aside class="notes" data-markdown>
When we do our database migrations,

- we are fine with adding tables
- adding columns and changing indices may cause locking problems (depending on database and how exactly you do it),
  but at least won't kill you
- but beware of column deletion.
  - if you are < 4.0
</aside>

          <h3>db:migrate</h3>
          <ul>
            <li class="fragment">Add table - OK</li>
            <li class="fragment">Add column, add/remove index - so-so</li>
            <li class="fragment">Remove column - oops <span class="fragment">(before 4.0)</span></li>
          </ul>

        </section>
        <!-- #37    try :remove_column --><section>

<aside class="notes" data-markdown>
If we try to remove (unused!) column while our application is running

- Either with migration or directly from database
- We will start to see a lot of errors
  - because Rails still thinks that this column exists.
</aside>

          <h3>try :remove_column</h3>

          <pre class="fragment"><code class="ruby" data-trim>
remove_column :extra_columns, :extra
          </code></pre>

          <pre class="fragment"><code class="sql" data-trim>
> ExtraColumn.create
   (0.2ms)  BEGIN
  SQL (34.9ms)  INSERT INTO "extra_columns" ("extra", "value") VALUES ($1, $2) RETURNING "id"  [["extra", nil], ["value", nil]]
   (0.2ms)  ROLLBACK
ActiveRecord::StatementInvalid: PG::Error: ERROR:  column "extra" of relation "extra_columns" does not exist at character 30
: INSERT INTO "extra_columns" ("extra", "value") VALUES ($1, $2) RETURNING "id"
          </code></pre>
          <pre class="fragment subst"><code class="sql" data-trim data-noescape>
> ExtraColumn.create
   (0.2ms)  BEGIN
  SQL (34.9ms)  INSERT INTO "extra_columns" ("extra", "value") VALUES ($1, $2) RETURNING "id"  [["extra", nil], ["value", nil]]
   (0.2ms)  ROLLBACK
<em>ActiveRecord::StatementInvalid: PG::Error: ERROR:  column "extra" of relation "extra_columns" does not exist at character 30</em>
<em>: INSERT INTO "extra_columns" ("extra", "value") VALUES ($1, $2) RETURNING "id"</em>
          </code></pre>
            
        </section>
        <!-- #38      img: train crash --><section>

<aside class="notes" data-markdown>
The worst part is that Rails will prevent your application from crashing, so this error will be there until your next
manual restart
</aside>

          <img src="images/rebels.jpg">
          <!-- cc
            PD A.J. Russell
            http://commons.wikimedia.org/wiki/File:A.J._Russell_(American_-_Railroad_Accident_Caused_by_Rebels_-_Google_Art_Project.jpg
          -->

        </section>
        <!-- #39    remove_column.inspect --><section>

<aside class="notes" data-markdown>
If we look at what is happening under the hood

- Rails memoizes what columns your tables have, and never tries to refresh them.
- The good side is that all operations are using this method - so we can 'inject' behavior we need easily
- And it works for all Rails versions. Almost.
  - Notice the gap.
</aside>

          <h3>remove_column.inspect</h3>

          <pre class="fragment w100"><code class="ruby" data-trim>
def columns
  @columns ||= connection.schema_cache.columns[table_name].map do |col|
    col = col.dup
    col.primary = (col.name == primary_key)
    col
  end
end
          </code></pre>
          <ul>
            <li class="fragment">All operations are defined in terms of klass.columns (directly or indirectly)</li>
            <li class="fragment">True for Rails 2.x, 3.0 <img class= "fragment smallTop" src="images/gap.jpg"> 3.2</li>
          </ul>

        </section>
        <!-- #40    remove_column.fix --><section>

<aside class="notes" data-markdown>
For fixing this we need to override this method in a model that have to loose the column

- The model will just pretend that it does not have it
- After updating your application and restarting
- We can safely remove the column,
- And remove this "hiding" code
- As with any pure cleanup, you are not forced to do deployment immediately
</aside>

          <h3>remove_column.fix</h3>

          <ul>
            <pre class="fragment" style="width:100%;"><code class="ruby" data-trim data-noescape>
class ExtraColumn < ActiveRecord::Base
  def self.columns
    @my_columns ||= super.reject{&nbsp;|c|
      c.name == 'extra'
    }
  end
end
            </code></pre>
            <li class="fragment">Deploy</li>
            <pre class="fragment"><code class="ruby" data-trim>
remove_column :extra_columns, :extra
            </code></pre></li>
            <li class="fragment">Remove ExtraColumn.columns</li>
            <li class="fragment">Deploy</li>
          </ul>

        </section>
        <!-- #41    remove_column.fix :rails_3_1 --><section>

<aside class="notes" data-markdown>
There should be some other way to do it for 3.1, but here is the answer I got on
StackOverflow. Let try to follow what it says:

Points 1 and 2 you need to do anyway, let start with 3:

* Start up a new database that is a master-master to your existing database
* Stop replication from your new database
* Drop your columns on the new database server
* One at a time reconfigure each application server to use the new database server and restart
* Turn replication back on for your new database
* Once the original server has caught back up, reconfigure the application to use that database server again (with
  applicable restarts)
* Stop replication and turn off new database server.
</aside>

          <h3>remove_column.fix :rails_3_1</h3>

          <img src="images/3.1.jpg">

        </section>
        <!-- #42      img: car_on_car  --><section>

<aside class="notes" data-markdown>
Woof...
</aside>

          <img src="images/car_on_car.jpg">
          <!-- cc
            Courtesy of the Boston Public Library, Leslie Jones Collection
            http://www.flickr.com/photos/boston_public_library/5786895180/
          -->

        </section>
        <!-- #43  Facet 4: Assets --><section>

<aside class="notes" data-markdown>
Let talk about asset pipeline
</aside>
          <ul>
            <li><h4>Facet #1: One and Only</h4> </li>
            <li><h4>Facet #2: I Can Haz One or Many?</h4></li>
            <li><h4>Facet #3: Emigration</h4></li>
            <li><h2>Facet #4: Assets & Liabilities</h2></li>
          </ul>

        </section>
        <!-- #44    deploy :shutdown --><section>

<aside class="notes" data-markdown>
To understand what can go wrong we need to look at how do we deploy our changes to servers.
One of valid methods of deployment is to

- shut down 
- all your servers
- replace your application
- and start up again

This is a very safe approach, but safety has its cost - and this cost is availability. You just took your site down
for unknown time.
</aside>
          <h3>deploy :shutdown</h3>
            <span>
              <img class="small" src="images/box_many_rails.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box.png">
              <img class="small" src="images/box.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box.png">
              <img class="small" src="images/box_many_rails_g.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box_many_rails_g.png">
              <img class="small" src="images/box_many_rails_g.png">
            </span>
        </section>
        <!-- #45    deploy :rolling_swap --><section>

<aside class="notes" data-markdown>
If you don't want to give away your availability, you have to go with rolling deployment. The most common way to do this
is to:

- deploy your new code to a single host
- restart the server to pick up changes
- deploy to the next one…
  
  but here is a problem. Each rails deployment has only one version of assets.

In this state (before restart) server is still serving red pages, but it already managed to
"forget" about all red assets - so clients are getting un-styled pages with no javascript.
The way to mitigate this problem is to use a mix of two strategies.
</aside>
          <h3>deploy :rolling_swap</h3>
            <span>
              <img class="small" src="images/box_many_rails.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box_many_rails_mix.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box_many_rails_g.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box_many_rails_g.png">
              <img class="small" src="images/box_many_rails_mix.png">
            </span>
        </section>
        <!-- #46    deploy :rolling_shutdown --><section>

<aside class="notes" data-markdown>
We are going to

- shut down the first host
- update application and start it
  
We are fine on this host, here is the second problem (with any rolling deployment) - unpredictable routing.
You never know which host assets for your page are served from.
Pages served from the red host can try to get assets from the green one, and vice versa.

</aside>
          <h3>deploy :rolling_shutdown</h3>
            <span>
              <img class="small" src="images/box_many_rails.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
            <span class="fragment subst">
              <img class="small" src="images/box_many_rails_g.png">
              <img class="small" src="images/box_many_rails.png">
            </span>
        </section>
        <!-- #47    rake assets:fix --><section>

<aside class="notes" data-markdown>
Fortunately Rails has almost all necessary pieces to avoid this problem (and give you a lot of additional benefits),
we just need to connect all dots together.

- We need to move our assets to a CDN
- If we use S3 for hosting assets, we can use 'asset_sync' gem that integrates asset uploading with asset compilation
- But in any case making sure all assets are uploaded to an asset host is not a rocket science
- We have to make sure that old assets are available for a time sufficient to finish deployment to all hosts (or even
  longer, in case you may need to roll back your changes)
- Just make sure that different versions of assets do not override each other
</aside>
          <h3>rake assets:fix</h3>
          <pre class="fragment"><code class="ruby" data-trim>
config.action_controller.asset_host = "//your.super.asset.host"
          </code></pre></li>
          <ul>
            <li class="fragment">For S3 you can use gem 'asset_sync'</li>
            <li class="fragment">... or roll out your own solution to upload precompiled assets before deployment</li>
            <li class="fragment">Do not delete old assets too early</li>
          </ul>
          <pre class="fragment"><code class="ruby" data-trim>
config.assets.digest = true
          </code></pre>
        </section>
        <!-- #48      img: fast  --><section>

<aside class="notes" data-markdown>
And we are rolling fast
</aside>

          <img src="images/fast.jpg">
          <!-- cc
            CC-BY-SA 3.0 Bhanutpt
            http://commons.wikimedia.org/wiki/File:Fast_Moving_Train_India.jpg
          -->

        </section>
        <!-- #49  Rails.why? --><section>

<aside class="notes" data-markdown>
This concludes our Rail-specific part. Remaining question is why resolution of such issues is left to developers?

- Rails goes out of its way to make simple tasks even simpler. It does this by adding a lot of magic tricks that hide
  what is going on behind the curtain.
- Unfortunately such hiding may (and will) strike back when your scenario even slightly deviate from the mainstream.
  (and what is mainstream is defined by rails core team). Looks like concurrency is not considered to
  be a problem common enough.
</aside>
          <h2>Rails.why?</h2>
          <div class="fragment">
            <blockquote cite="http://david.heinemeierhansson.com/2012/rails-is-omakase.html">
              Rails is omakase. A team of chefs picked out the ingredients, designed the APIs, and arranged the order
              of consumption on your behalf according to their idea of what would make for a tasty full-stack framework.
            </blockquote>
            <p class="author">DHH</p>
          </div>
          <small class="fragment">
            NOTICE: Consuming raw or undercooked meats, poultry, seafood, shellfish, or eggs may increase your risk
            of foodborne illness
          </small>
        </section>
        <!-- #50 Part 2. Off Rails --><section>

<aside class="notes" data-markdown>
And now, finally, we are up to more interesting and not Rails-only stuff
</aside>

          <h2>Part 2</h2>
          <h3>Off Rails</h3>

        </section>
        <!-- #51  Development and Deployment --><section>

<aside class="notes" data-markdown>
The problem we we are going to look at is a problem of incremental functionality change

- Long ago ex - US Secretary of Defence described development and deployment as hardly combinable. Almost 30 years later
we all moved to this counterproductive environment as our everyday lifestyle. We are constantly developing and deploying
concurrently.
</aside>
          <h3>Development and Deployment</h3>
          <div class="fragment">
            <blockquote cite="http://david.heinemeierhansson.com/2012/rails-is-omakase.html">
              Concurrency of development with deployment . . . has almost always proven counterproductive
            </blockquote>
            <p class="author">Harold Brown</p>
          </div>

        </section>
        <!-- #52    Call for volunteers --><section>

<aside class="notes" data-markdown>
Here we see already familiar picture of our rolling deployment in the flight.

- To show what can and will happen I'll need some help

Two of you will be servers, other two - clients, and I'll be a router. Dear servers, please do not answer ny requests
until I route it to you!

- Server One: You have a simple API: on request "What do you have?" you are going to respond: "I have a candy in my
  left pocket".

  Please put it there. And on request "Please give me a candy from your left pocket" you'll share what you have. Please
  do not be greedy!

- Client one: please ask the server "What do you have?"  
- Dear server, please answer [I have a candy in my left pocket]
- For now, client one, you are distracted by what is going around, so please hold on your second request (I hope you can
  survive couple minutes without a candy?)
- Server Two, you are my new improved version. Your drastic improvement is that you have a candy in your right pocket.
- Client Two, please ask "What do ypu have?"
- Server Two, please answer [I have a candy in my right pocket]
- Client Two, please ask for your candy. You remember where it is? 
- I am routing this to you, Server One. Please give him a candy from your right pocket… What, you do not have it there?
  Please show us your interpretive dance for "Page not found"
- OK, Client One, time to wake up. You remember what to ask? [Please give me a candy from your left pocket]
- Server Two, as ypu are an improved version, ypu just crash on this request. Please show us "Server Down"
</aside>
          <h3>Development and Deployment</h3>
          <img class="small" src="images/box_many_rails_g.png">
          <img class="small" src="images/box_many_rails.png">
          <img class="small" src="images/box_many_rails.png">
          <img class="small" src="images/box_many_rails.png">
          <img class="small" src="images/box_many_rails.png">
          <p class="fragment">I Can Haz Four Volunteers?</p>
        </section>
        <!-- #53    changed_feature.deploy! --><section>

<aside class="notes" data-markdown>
Now let fix this issue

- Server One, your API does not change, but I am giving yo a candy to put in your right pocket
- Server Two, here is one for your left pocket
- Now I can successfully deploy you, even if Server One is still around
- We need to wait some time till all potential requests are satisfied (please, give one of your candies to the clients
  each). Remember, that we need to wait all the time necessary for all clients to be satisfied
  (or you define what is "too late" and accept the fact that you have no chance to satisfy 100%)
- Now ypu can cleanup your backwards-compatibility code. For us cleanup means that I thank you for your help!

  - You should always treat your web server as an API provider
  - In software-as-a-service world, nobody would even imagine dropping a new
  API version without sufficient grace period, but web application developers do this all over the places.
</aside>
          <h2>changed_feature.deploy!</h2>
          <ol>
            <li class="fragment">Teach old dog new tricks (but do not show them)</li>
            <li class="fragment">Teach new dog old tricks</li>
            <li class="fragment">Swap your dogs</li>
            <li class="fragment">Wait...</li>
            <li class="fragment">Now you can forget old tricks</li>
          </ol>
          <ul>
            <li class="fragment">
              Your website is an API server and a client at the same time (but client is behind!)
            </li>
            <li class="fragment">Treat changing features as a new API version</li>
          </ul>
        </section>
        <!-- #54 quiz recap --><section>

<aside class="notes" data-markdown>
So, returning to our starting quiz,

- you should not worry about the concurrency only if you do not care (BTW, "do not care"" is not necessarily negligence.
  Sometimes nature of your application may make you ether safe from such problems, or potential impact of concurrency
  issues is very limited)
- But if you do, remembering all potential sources of concurrency problems will help you to find a solution.
</aside>

          <h3>
            You may not worry about concurrency if:
          </h3>
          <ul>
            <li class="fragment">You do not care</li>
            <li class="fragment">But if you do – worry, and you will (almost) always find your way</li>
          </ul>

        </section>
        <!-- #55   img: many ways  --><section>

<aside class="notes" data-markdown>
One way or another...
</aside>

          <img src="images/many_ways.jpg">
          <!-- cc
            CC BY-NC-ND 2.0 SCFiasco
            http://www.flickr.com/photos/scfiasco/4490322916/
          -->

        </section>
        <!-- #56 Bonus --><section>

<aside class="notes" data-markdown>
This exercise can help you to train your "concurrent" thinking

- Design an application that can help prepare slides for a talk
  - User can add a ToDo item in arbitrary place
  - User can easily move slides (or even move groups of slides) around
  - There should not be explicit "save"
- Focus on what is send over the network and what is persisted in your database. You get your points for considering:
  - Blocking vs. non-blocking saves
  - Some messages about user moving slides around can be lost
  - Or just come out-of-order
  - User can have your application opened in a different browser tab (or even on different computer) and can not notice
  that she sees several hours old copy.
  - Extra bonus - collaborative editing

Please feel free to use this question on your interviews, or even come with prepared answer to mine.
</aside>
          <h3>Homework</h3>
          <h4 class="fragment">Design a Presentation Web App</h4>
          <ul>
            <li class="fragment">User can add a slide at an arbitrary place</li>
            <li class="fragment">User can easily reorder slides</li>
            <li class="fragment">All edits are saved "behind the scenes"</li>
          <h4 class="fragment">Consider:</h4>
            <ul>
              <li class="fragment">Synchronous vs. asynchronous messaging</li>
              <li class="fragment">Lost slide reordering messages</li>
              <li class="fragment">Reordering messages coming out-of-order</li>
              <li class="fragment">User adding, editing and/or reordering on a stale page</li>
              <li class="fragment">Extra bonus: collaborative editing</li>
            </ul>
          </ul>
        </section>
        <!-- #57 credits --><section>

<aside class="notes" data-markdown>
I'd like to (and in some cases have to) thank everybody who made this presentation possible
</aside>
          <h4>Credits</h4>
          <ul class="tiny">
            <li>Hakim El Hattab - Reveal.js, http://lab.hakim.se/reveal-js/#/
            <li>"Concurrency." Merriam-Webster.com. Merriam-Webster, n.d. Web. 23 Aug. 2013. [http://www.merriam-webster.com/dictionary/concurrency]</li>
            <li>Wikipedia - http://en.wikipedia.org/wiki/Concurrency_(computer_science)</li>
            <li>David Heinemeier Hansson - http://david.heinemeierhansson.com/2012/rails-is-omakase.html</li>
            <li>Harold Brown - http://www.foreignaffairs.com/articles/40540/harold-brown/is-sdi-technically-feasible</li>

            <li>Images:</li>
            <ul>
              <li>Garrett Fitzgerald - http://commons.wikimedia.org/wiki/File:SeattleMonorailAccident.jpg</li>
              <li>SoRah42 - http://sorah42.deviantart.com/art/Unique-187278898</li>
              <li>http://commons.wikimedia.org/wiki/File:GuateQuake1976BentRailsA.jpg</li>
              <li>http://en.wikipedia.org/wiki/File:Train_wreck_at_Montparnasse_1895.jpg</li>
              <li>Courtesy of the Boston Public Library, Leslie Jones Collection:
                <ul>
                  <li>http://www.flickr.com/photos/boston_public_library/5786875562/</li>
                  <li>http://www.flickr.com/photos/boston_public_library/5786895180/</li>
                </ul>
              <li>John McNab - http://www.flickr.com/photos/johnmcnab/6511819727/</li>
              <li>Mike Campbell - http://www.flickr.com/photos/morphyoss/4963981594/</li>
              <li>Swansea - http://www.freefoto.com/download/23-22-1/Swansea-London-Paddington-High-Speed-Train--HST-</li>
              <li>http://commons.wikimedia.org/wiki/File:Loket_vid_j%C3%A4rnv%C3%A4gsolyckan_i_Get%C3%A5_1918.jpg</li>
              <li>A.J. Russell - http://commons.wikimedia.org/wiki/File:A.J._Russell_(American_-_Railroad_Accident_Caused_by_Rebels_-_Google_Art_Project.jpg</li>
              <li>Bhanutpt - http://commons.wikimedia.org/wiki/File:Fast_Moving_Train_India.jpg</li>
              <li>SCFiasco - http://www.flickr.com/photos/scfiasco/4490322916/</li>
            </ul>
          </ul>
        </section>
        <!-- #58 Q & A --><section>

<aside class="notes" data-markdown>
And now we are ready for Q&A session.
</aside>
          <h1>Q & A</h1>
        </section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: 'default', //Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'lib/js/fullscreen-img.js' }

					//{ src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
      Reveal.addEventListener( 'fragmentshown', function( event ) {
        if (event.fragment.className.match(/(?:^|\s)subst(?!\S)/)) {
          event.fragment.previousElementSibling.className += " hidden";
        } 
      });
      Reveal.addEventListener( 'fragmenthidden', function( event ) {
        if (event.fragment.className.match(/(?:^|\s)subst(?!\S)/)) {
          event.fragment.previousElementSibling.className = 
            event.fragment.previousElementSibling.className.replace( /(?:^|\s)hidden(?!\S)/g , '' );
        }
      });
      Reveal.addEventListener( 'slidechanged', function( event ) {
        // event.previousSlide, event.currentSlide, event.indexh, event.indexv
        var notes = event.currentSlide.querySelector(".notes");
        if(notes) {
          console.info(notes.innerHTML.replace(/\n\s+/g,'\n'));
        }
      } );
		</script>

	</body>
</html>
